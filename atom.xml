<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Wenqi&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-08-06T00:59:40.714Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Wenqi</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>深度优先搜索总结</title>
    <link href="http://yoursite.com/2018/06/25/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/06/25/深度优先搜索总结/</id>
    <published>2018-06-25T01:39:00.000Z</published>
    <updated>2018-08-06T00:59:40.714Z</updated>
    
    <content type="html"><![CDATA[<p>深度优先搜索(DFS)和广度优先搜索(BFS)都是一种对可能解答路径的枚举方式，深度优先搜索每次都从一个方向一直搜索到最终状态，然后进行回溯尝试枚举其他到达最终状态的路径。回溯的过程需要存储回溯点当前的状态，递归方法可以很好的完成这个任务，在递归方法之前设置状态信息，在递归后将状态信息设置回原值。如果设计递归方法是关键，递归方法对应着深度优先搜索的策略。本文尝试从几个例子尝试探索使用深度优先搜索方法的一般设计方法。<br><a id="more"></a></p><h2 id="二维矩阵两点之间的路径遍历"><a href="#二维矩阵两点之间的路径遍历" class="headerlink" title="二维矩阵两点之间的路径遍历"></a>二维矩阵两点之间的路径遍历</h2><p>一个典型的问题是迷宫问题，给出一个迷宫矩阵，0代表可以走的位置，1代表墙的位置，给出起始和出口位置的坐标，求出最小步数走出迷宫的路径，并且打印出这个路径。<br>解决这个问题的基本想法是枚举所有的从起始位置到出口位置的路径，并记录最短的那条路径，那么应该怎么样才可以全面不漏的列举所有的路径呢？我们从一个坐标点(x,y)出发，那么经过一步可以走的方向有上下左右四个方向，也就是（x-1,y）,(x+1,y),(x,y-1),(x,y+1)。计算了下一步的位置，我们需要判断，新的位置是否在矩阵内，是否是墙，是否是出口节点，如果不是上面以上特殊节点，我们就可以把新的节点作为基地继续上面的搜索过程。<br>很显然，以上的搜索过程可以用递归写出来，其中定义递归转移的状态是当前的的坐标，出口为下一个位置为出口位置，对于在矩阵内的不是墙，不是出口节点的搜索方法是朝4个方向进行探索。<br>除了输入信息：矩阵行列数，迷宫矩阵，起始坐标，输出信息：最小步数，最小步数路径，我们还需要一些辅助容器，为了方便我们对下一个位置的计算，我们定义一个4*2的二维数组，可以使用循环的方式对下一个位置进行计算，如向上可以使用（-1,0）加上原来的（x,y）进行计算。总的来说，我们需要的信息如下,可以通过声明全局变量的方式进行声明<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//输入值定义为全局变量</span></div><div class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> maze[][];</div><div class="line">   <span class="comment">//行，列</span></div><div class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> xlen, ylen;</div><div class="line">   <span class="keyword">public</span> <span class="keyword">static</span> Position start,end;</div><div class="line"></div><div class="line">   <span class="comment">//辅助全局常量</span></div><div class="line">   <span class="comment">//上下，左右</span></div><div class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> directions[][]=&#123;&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;&#125;;</div><div class="line"></div><div class="line">   <span class="comment">//结果容器</span></div><div class="line">   <span class="comment">//用于存储最优的路径</span></div><div class="line">   <span class="keyword">public</span> <span class="keyword">static</span> Stack&lt;Position&gt; optimalStack=<span class="keyword">null</span>;</div><div class="line">   <span class="comment">//设置为最大值</span></div><div class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> optimalStep=Integer.MAX_VALUE;</div></pre></td></tr></table></figure></p><p>定义好需要的信息，我们就可以设计算法获取结果，如何进行计算呢，其基本思路是下面这样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">输入行列数</div><div class="line">输入矩阵</div><div class="line">输入起始位置和出口位置</div><div class="line"></div><div class="line">将初始位置作为初始点进行搜索并将最优结果存储到结果容器中</div><div class="line"></div><div class="line">输出最优的结果</div></pre></td></tr></table></figure></p><p>那么如何”将初始位置作为初始点进行搜索并将最优结果存储到结果容器中”,这个是算法核心，因为求的是最优的结果，所以我们不能直接在optimalStep和optimalStack进行存储，需要在算法计算的时候为它们声明一个副本，然后在到达出口节点的时候将副本step与optimalStep比较，如果step小于optimalStep，那么应该将optimalStep变成step，并且用optimalStack记录当前的stack路径。<br>按照上面的思路，我们的递归方法的参数应该是（x,y,step,stack），即当前的坐标，当前已走的步数，当前的路径坐标栈。因为结果会在全局变量中更新，所以不需要返回值，按此思路，设计算法如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">描述：深度搜索过程</div><div class="line">输入：当前的坐标(x,y),当前已走的步数，当前的路径栈</div><div class="line">输出：结果在全局变量中更新</div><div class="line">对于4个方向选取一个当前方向，做如下循环</div><div class="line">计算在从当前坐标走向当前方向的的新坐标(nx,ny)</div><div class="line">如果(nx,ny)超出当前矩阵的范围，则尝试下一个方向</div><div class="line">如果(nx,ny)是墙，则尝试下一个方向</div><div class="line">如果(nx,ny)是出口坐标，做如下动作</div><div class="line">将当前步数step+1，并将出口节点存储到路径stack中</div><div class="line">如果当前step&lt;optimalStep，则optimalStep=step,optimalStack=stack</div><div class="line">将步数step-1,弹出出口位置，为下一次探索做准备</div><div class="line">如果不是以上三种情况，则执行如下动作</div><div class="line">将当前步数step+1,并且将(nx,ny)存储到stack中，并将(nx,ny)置为墙</div><div class="line">以（nx,ny,step,stack）为新的状态做搜索</div><div class="line">将步数回溯置为step-1,并且将(nx,ny)弹栈，将(nx,ny)置为非墙</div></pre></td></tr></table></figure></p><p>以上即为深度搜索的算法，可见深度优先搜索是依赖于递归进行的，其中状态，特殊位置处理，搜索方法是三驾马车，其中状态的设计是根本。使用栈存储变量的路径是十分有效的方法，在递归方法上的路径存储基本上都是使用栈来进行，在递归回来的时候可以使用弹栈的方式继续进行搜索。其中看在递归的前后还将当前位置设置为墙，为的是方式新的状态返回到当前状态，递归返回后，我要将其设置回来。<br>每个状态都是递归计算的，这意味着每个状态的计算都是可以重复的，一样的，不一样之处应该在特殊位置进行处理，通常剪枝和出口都在特殊位置状态进行处理。<br>如此，我们便可以轻松写出深度搜索的方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,Stack&lt;Position&gt; stack, <span class="keyword">int</span> step)</span></span>&#123;</div><div class="line">      <span class="comment">//从当前的节点网四个方向试探</span></div><div class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</div><div class="line">          <span class="comment">//获取下一个位置的坐标进行判断</span></div><div class="line">          <span class="keyword">int</span> nx=x+directions[i][<span class="number">0</span>];</div><div class="line">          <span class="keyword">int</span> ny=y+directions[i][<span class="number">1</span>];</div><div class="line">          <span class="comment">//超过迷宫范围</span></div><div class="line">          <span class="keyword">if</span>(nx&lt;<span class="number">1</span>||nx&gt;xlen||ny&lt;<span class="number">1</span>||ny&gt;ylen)</div><div class="line">              <span class="keyword">continue</span>;</div><div class="line">          <span class="comment">//新节点位置为墙</span></div><div class="line">          <span class="keyword">if</span>(maze[nx][ny]==<span class="number">1</span>)</div><div class="line">              <span class="keyword">continue</span>;</div><div class="line">          <span class="keyword">if</span>(nx==end.x&amp;&amp;ny==end.y)&#123;</div><div class="line">              <span class="comment">//到达节点目标位置</span></div><div class="line">              <span class="comment">//如果当前步数小于最优步数，则更新最优步数为当前步数</span></div><div class="line">              step++;</div><div class="line">              stack.push(<span class="keyword">new</span> Position(nx,ny));</div><div class="line">              <span class="keyword">if</span>(step&lt;optimalStep)&#123;</div><div class="line">                  optimalStack =(Stack&lt;Position&gt;)stack.clone();</div><div class="line">                  optimalStep=step;</div><div class="line">              &#125;</div><div class="line">              step--;</div><div class="line">              stack.pop();</div><div class="line">              <span class="keyword">return</span>;</div><div class="line">          &#125;</div><div class="line"></div><div class="line">          <span class="comment">//如果不是最终节点的处理方式,可以跳到步子上，从新的节点上张望</span></div><div class="line">          <span class="comment">//站到下一个节点上（步数加一，压栈），并在新的节点上做深度遍历</span></div><div class="line">          step++;</div><div class="line">          stack.push(<span class="keyword">new</span> Position(nx,ny));</div><div class="line">          maze[nx][ny]=<span class="number">1</span>;</div><div class="line">          dfs(nx,ny,stack,step);</div><div class="line">          step--;</div><div class="line">          stack.pop();</div><div class="line">          maze[nx][ny]=<span class="number">0</span>;</div><div class="line"></div><div class="line">      &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p><p>在main函数中，我们就可以直接调用dfs(start.x,start.y,0,new Stack())后获取最优的结果。</p><h2 id="二维矩阵连通区域计算"><a href="#二维矩阵连通区域计算" class="headerlink" title="二维矩阵连通区域计算"></a>二维矩阵连通区域计算</h2><p>再来一个二维矩阵的深度优先搜索例子：给出一个矩阵，其中*代表空，@代表油田，一块油田的上下左右和对角相邻位置视为连通，连通的油田是一块区域，给出一个这样的矩阵，计算出连通区域的个数。<br>明确我们的目的是求出所有的连通区域的个数，基本想法是遍历所有的矩阵点，对于所有的油田点进行深度搜索，目的是将与当前油田点标记为已访问状态；而对于已访问的矩阵点或者空点不做处理。<br>我们的输入变量有矩阵行列，矩阵，输出变量是连通区域数，我们还需要辅助变量方向数组和标记数组，其中标记数组用来标记一个节点是否已经被访问到了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//输入变量</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">char</span> maze[][];</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> row,col;</div><div class="line"></div><div class="line"><span class="comment">//辅助变量</span></div><div class="line"><span class="comment">//标志是否已经归入某个区域</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> mark[][];</div><div class="line"><span class="comment">//分别是左上，上，右上，左，右，左下，下，右下</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> directions[][]=&#123;&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,-<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">1</span>&#125;&#125;;</div><div class="line"></div><div class="line"><span class="comment">//结果变量</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> ans;</div></pre></td></tr></table></figure></p><p>递归方法的设计，转移状态应该是当前的油田节点的坐标(x,y)，计算新的节点(nx,ny)有三个特殊状态:出界，空点，已访问的点，这三种状态应该直接跳过，进行下一个方向的尝试，处理以上三个特殊状态，那么就剩下未访问的相邻油田，应该设置新的油田节点为已访问状态，并且以(nx,ny)为新基点进行递归探寻。其核心思想如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">描述：标记和一个油田节点在同一连通区域的所有油田点</div><div class="line">输入：当前油田点的坐标位置</div><div class="line">输出：标记即可，标记完后结果数加一</div><div class="line">对于8个方向计算新的下一个节点，做如下操作</div><div class="line">新的节点为(nx,ny)</div><div class="line">如果新的节点不再矩阵内，尝试下一个方向</div><div class="line">如果新的节点是空或者已被访问，尝试下一个方向</div><div class="line">不是以上三种情况，做如下操作</div><div class="line">标记（nx,ny）为已访问状态</div><div class="line">以(nx,ny)为基础状态递归调用</div></pre></td></tr></table></figure></p><p>根据以上，我们写出java代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)&#123;</div><div class="line">        <span class="keyword">int</span> nx=x+directions[i][<span class="number">0</span>];</div><div class="line">        <span class="keyword">int</span> ny=y+directions[i][<span class="number">1</span>];</div><div class="line">        <span class="keyword">if</span>(nx&lt;<span class="number">1</span>||ny&lt;<span class="number">1</span>||nx&gt;row||ny&gt;col)</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        <span class="keyword">if</span>(maze[nx][ny]==<span class="string">'*'</span>)</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        <span class="keyword">if</span>(mark[nx][ny]==<span class="keyword">true</span>)</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        <span class="comment">//设置相邻位置为已连通状态</span></div><div class="line">        mark[nx][ny]=<span class="keyword">true</span>;</div><div class="line">        dfs(nx,ny);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="二叉树的最长路径"><a href="#二叉树的最长路径" class="headerlink" title="二叉树的最长路径"></a>二叉树的最长路径</h2><p>说完了二维矩阵的深度优先遍历，下面我们举个二叉树的深度优先遍历的应用，即给出一个二叉树，打印出最长的从根到叶子节点的路径。<br>如果仅仅是求最长的路径是多少，我们使用层次遍历即可，也就是对应于广度优先遍历，而如果要把路径求出来，需要深度优先遍历所有的路径，记录最长的那一条。<br>我们的输入是一个树根，需要辅助的变量有临时的路径栈和临时路径长，输出是最长的路径和路径长，临时路径栈和临时路径长可以作为方法参数传递，所以我们只需要定义全局的输出信息。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//输出信息</span></div><div class="line">   <span class="keyword">public</span> <span class="keyword">static</span> Stack&lt;TreeNode&gt; longestTrace;</div><div class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> longestLength=<span class="number">0</span>;</div></pre></td></tr></table></figure></p><p>深度优先递归的状态是当前的节点，还有作为参数传递的临时路径栈和临时路径长。特殊位置点有两个，一是如果当前节点是null，则直接返回，二是如果当前节点是叶子节点，则应该比较当前的路径长度和最长的路径长度，如果当前的路径长度更长，则应该更新最长的路径长度和路径栈。<br>其他情况，递归遍历左子树和右子树。其实现过程如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">findLongestTrace</span><span class="params">(TreeNode root,<span class="keyword">long</span> length,Stack&lt;TreeNode&gt; trace)</span></span>&#123;</div><div class="line">      <span class="keyword">if</span>(root==<span class="keyword">null</span>)</div><div class="line">          <span class="keyword">return</span>;</div><div class="line">      <span class="keyword">if</span>(isLeaf(root))&#123;</div><div class="line">          length++;</div><div class="line">          trace.push(root);</div><div class="line">          <span class="keyword">if</span>(length&gt;longestLength)&#123;</div><div class="line">              longestTrace=(Stack&lt;TreeNode&gt;) trace.clone();</div><div class="line">              longestLength=length;</div><div class="line">          &#125;</div><div class="line">          length--;</div><div class="line">          trace.pop();</div><div class="line">      &#125;</div><div class="line">      <span class="comment">//非叶子节点</span></div><div class="line"><span class="comment">//左子树不空</span></div><div class="line">      <span class="keyword">if</span>(root.left!=<span class="keyword">null</span>)&#123;</div><div class="line">          length++;</div><div class="line">          trace.push(root);</div><div class="line">          findLongestTrace(root.left,length,trace);</div><div class="line">          length--;</div><div class="line">          trace.pop();</div><div class="line">      &#125;</div><div class="line"><span class="comment">//右子树不空</span></div><div class="line">      <span class="keyword">if</span>(root.right!=<span class="keyword">null</span>)&#123;</div><div class="line">          length++;</div><div class="line">          trace.push(root);</div><div class="line">          findLongestTrace(root.right,length,trace);</div><div class="line">          length--;</div><div class="line">          trace.pop();</div><div class="line">      &#125;</div><div class="line"></div><div class="line">  &#125;</div></pre></td></tr></table></figure></p><h2 id="隐式深度优先搜索-素数环"><a href="#隐式深度优先搜索-素数环" class="headerlink" title="隐式深度优先搜索-素数环"></a>隐式深度优先搜索-素数环</h2><p>有的问题可以通过优先搜索的方式解决，但是状态的定义并不像上面二维数组，树啊的那么容易定义，一个典型的例子就是素数环问题，给你一个数，比如6，让你将1-6所有能组成素数环的排列全部列出，素数环排列必须以1开始。所谓素数环，指的是任意相邻的数和都为素数，最后一个数和第一个数和也为素数。<br>我们的输入只有一个数，但是却隐含了一个数组，解决这个问题的基本想法是遍历所有的以1开始的所有排列，但是怎么遍历，肯定不能用多个循环，我们可以定义状态为当前放入的位置index,以6为例，我们尝试从放入6个位置的数，每个数从2-6中选取，如果一个状态不符合，可以立即进行回退尝试下一个数字，如果符合，则可以尝试下一个位置，直至到达容量。<br>为了完成这个任务，我们需要对6个数字进行标记是否处于已选入状态，如果是，则不应该再次选入。所以我们需要以下变量的支持。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">//输入变量</div><div class="line">    private static int n;</div><div class="line"></div><div class="line">    //辅助变量</div><div class="line">    //标记变量是否被访问到过</div><div class="line">    private static boolean[] flag;</div><div class="line"></div><div class="line">    //结果容器</div><div class="line">    private static int caseNum;</div><div class="line">    //代替栈</div><div class="line">    private static int[] ans;</div></pre></td></tr></table></figure></p><p>我们的状态是当前已经放置的位置index，刚开始我们会将1放入，并且标记1为已选中状态。对于一个已放入状态的index，我们需要检查比较index和index-1位置的和是否为素数，这是每一个index都需要做的事情。对于特殊位置index==n,意味着位置已经放完，应该检查index位置和1位置的值和是否为素数，如果是，则成功查找到一个，将其放入到结果容器中，然后返回。搜索的过程是查找2-n中未选中的数，尝试将其放入index+1位置，并递归调用index+1位置。在此之前应该设置选中的数为已选中状态，返回的时候将其设置为未选中状态。整个思路如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(index&gt;<span class="number">1</span>)&#123;</div><div class="line">        <span class="comment">//开始检查后两个和是否为质数,不是的话直接返回</span></div><div class="line">        <span class="keyword">if</span>(!prime.contains(ans[index]+ans[index-<span class="number">1</span>]))</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(index==n)&#123;</div><div class="line">        <span class="comment">//已经放入最后一个数，检查第一个数和最后一个数的和是否仍为质数</span></div><div class="line">        <span class="keyword">if</span>(prime.contains(ans[index]+ans[<span class="number">1</span>]))&#123;</div><div class="line">            caseNum++;</div><div class="line">            System.out.println(<span class="string">"Case "</span>+caseNum);</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</div><div class="line">                System.out.print(ans[i]+<span class="string">" "</span>);</div><div class="line">            &#125;</div><div class="line">            System.out.println();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//非出口节点</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++) &#123;</div><div class="line">       <span class="keyword">if</span>(flag[i]==<span class="keyword">false</span>)&#123;</div><div class="line">           <span class="comment">//i可以尝试放入结果中</span></div><div class="line">           ans[index+<span class="number">1</span>]=i;</div><div class="line">           <span class="comment">//将i位置的值设置为已用</span></div><div class="line">           flag[i]=<span class="keyword">true</span>;</div><div class="line">           dfs(index+<span class="number">1</span>);</div><div class="line">           <span class="comment">//递归回来设置i为可以用的状态</span></div><div class="line">           flag[i]=<span class="keyword">false</span>;</div><div class="line">       &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这种隐式的深度优先递归的放入位置比较难想，这里一个数就相当于一个尝试的点，需要在递归的内部进行循环遍历，这样就变相的实现了多重循环的实现。</p><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>本文首发表于<a href="https://buwenqi.github.io" target="_blank" rel="external">我的博客</a>,欢迎关注！已委托维权骑士为本站的文章进行维权，转载须注明文章出处，作者保留文章所有权。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;深度优先搜索(DFS)和广度优先搜索(BFS)都是一种对可能解答路径的枚举方式，深度优先搜索每次都从一个方向一直搜索到最终状态，然后进行回溯尝试枚举其他到达最终状态的路径。回溯的过程需要存储回溯点当前的状态，递归方法可以很好的完成这个任务，在递归方法之前设置状态信息，在递归后将状态信息设置回原值。如果设计递归方法是关键，递归方法对应着深度优先搜索的策略。本文尝试从几个例子尝试探索使用深度优先搜索方法的一般设计方法。&lt;br&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>背包问题总结</title>
    <link href="http://yoursite.com/2018/06/24/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/06/24/背包问题总结/</id>
    <published>2018-06-24T08:56:08.000Z</published>
    <updated>2018-08-06T00:59:29.182Z</updated>
    
    <content type="html"><![CDATA[<p>背包问题是经典动态规划思想的应用实例。其基本问题是:在拥有一个固定容量的背包的情况下，如何选择不同体积并且价值不同的物品装入背包中，使得背包中的物品的价值最大。也就是说物品有两个维度的属性：体积和价值，而背包限制了总体积。针对这个问题，衍生出不同的背包问题。<br><a id="more"></a></p><h2 id="0-1背包问题"><a href="#0-1背包问题" class="headerlink" title="0-1背包问题"></a>0-1背包问题</h2><p>背包问题的基本条件：背包容量V和一些物品，物品有体积和价值两个属性。0-1背包的问题限制的条件是每个物品只有一种，要么放入背包，要么不放入，如何才能使得背包获得最大的价值，最终的结果，背包可以不被放满。</p><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>解决方法是动态规划，动态规划解决问题首先要抽象出一个数字化的<strong>状态</strong>，然后可以确定状态的初始化状态并且可以写出状态的转移方程。后一个状态的转移计算应该依赖于已经计算出来的前面状态(可能是多个)。为了达到全局最优，前一个状态应该是局部最优的，并且后一个状态的计算依赖于前一个状态计算能够达到最终的全局最优，这被称为问题具有<strong>最优子结构</strong>。并且每一个局部最优状态不会因为后面的计算而发生改变，这被称为<strong>无后效性</strong>。简单来说，动态规划的一个最优状态依赖于多个局部最优的结果而得出，这也就是为什么动态规划需要填表的原因。贪婪算法从原则上来说动态规划的一种特例，贪婪算法后一个状态只依赖于最优的前一个状态，而不是多个。</p><h3 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h3><p>我们回来来看0-1背包问题，为了计算出指定背包容量的最优值，我们定义一个<strong>状态数组</strong>，dp[i][j]=maxValue,我们用行标i表示这次尝试放入下标是i的物品，而列标j代表当前的背包的容量，而值maxValue代表将前i个物品放入背包容量为j的背包中所能获取的最大值。当然这个状态的挑选本身并不容易想，这个状态的值决定了在j容量的前提下前i物品的选择最优值，也就是我们说的局部最优，并且它是确定的，不会因为后面的选择而改变。有了这个状态值的定义，我们就可以类似于数学归纳法一样，首先确定初值，然后层层递进求解。<br>那么初值是什么呢？初值是不放物品的情况下，即i为0的情况下，不论背包容量j有多大，我们的maxValue始终是0，即dp[0][j]=0,这个就是初值。<br>有了初值后，我们就可以利用这个初值状态计算dp[1][j],dp[2][j]等等，我们需要推出一个通用的公式来求dp[i][j],这样我们就可以用循环来进行迭代计算。要算dp[i][j],也就是尝试将第i个物品放入容量为j的背包，那么我们有两种选择，将i放入背包后的价值and不放入i的价值，我们只有这两种选择，这是个二分选择问题。如果我们将i放入背包，那么肯定要预留i的位置，那么放入i后的价值是dp[i-1][j-w[i]]+v[i],w[i]，v[i]代表i的重量和价值，其中dp[i-1][j-w[i]]是已经计算好的前i-1个物品放入背包容量减去i重量的最大价值，这个是子最优值。另一方面，如果不放入i物品，前i个物品的价值就取前i-1个物品的最优值，即dp[i-1][j]。最后dp[i][j]取这两者的最大值，也就是这次选择的最优值，即dp[i][j]=max{dp[i-1][j-w[i]]+v[i],dp[i-1][j]}。<br>这个看着复杂的式子就是我们进行迭代计算的根本，后一个的最优值是基于前一个的最优值计算的，如此层层迭代，最终得到我们的结果。回过头来，我们想想这种动态规划的方法为什么会得到全局最优，而贪婪算法却不能，从过程中来看，我们每层的计算都是基于前一层的最优值，并且在最优值上做了二分选择，这是和贪婪策略完全不同之处。<br>单纯的理论解释不太容易理解，算法的学习最好的方法就是使用例子进行手工推演，看整个过程中数据是如何变化的，这种方法更容易理解算法运作的过程。<br>下图是我们使用背包为10，尝试从四个重量和价值不同的物品装入，使背包中的价值最大。除了物品编号为0的行都为0外，其他行都是通过我们上面总结的递归公式得来的。例如物品编号为2，背包容量为4的情况下，背包容量是max{dp[1][4-2]+3,dp[1][4]}=max{9,6}=9，所以在背包容量为4时候，前两个物品放入的最大价值是9。<br>再看个复杂点的，当物品编号是4，背包容量是9的时候，dp[4][9]=max{dp[3][9-5]+4,dp[3][9]}=max{9+4,11}=13。<br><img src="https://i.imgur.com/NaCVeta.png" alt=""><br>其中，灰色的部分，是背包容量小于当前的物品重量的情况，这种情况下，只要将dp[i][j]置为dp[i-1][j],而红色部分表示dp[5][10]回溯的过程，可以根据这个回溯过程，看出选择的过程。<br>有了整个过程了理解，我们很容易写出整个算法过程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">输入：背包容量C，物品个数num，以及每个物品的重量w[i],价值v[i]</div><div class="line">输出：当背包容量为C时候的最大价值</div><div class="line">置dp[0][j]为0，j&lt;=C</div><div class="line">对于第i个物品，i&lt;=num,做如下循环</div><div class="line">对于容量j从0开始，j&lt;=C,做如下循环</div><div class="line">如果j&lt;w[i],则dp[i][j]=dp[i-1][j]</div><div class="line">否则，dp[i][j]=max&#123;dp[i-1][j],dp[i-1][j-w[i]]+v[i]&#125;</div><div class="line">返回dp[num][C]即为当背包容量为C时候的最大值</div></pre></td></tr></table></figure></p><p>核心java代码实现如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> dpValue[][]=<span class="keyword">new</span> <span class="keyword">int</span>[stuffNum+<span class="number">1</span>][packCapacity+<span class="number">1</span>];</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=packCapacity;i++)</div><div class="line">dpValue[<span class="number">0</span>][i]=<span class="number">0</span>;<span class="comment">//不放任何物品的总价值为0</span></div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=stuffNum;i++)</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=packCapacity;j++) &#123;</div><div class="line"><span class="comment">//如果当前背包容量小于第j个物品的重量,则价值为上一层的最优价值</span></div><div class="line"><span class="keyword">if</span>(j&lt;stuffArray[i].getWeight()) </div><div class="line">dpValue[i][j]=dpValue[i-<span class="number">1</span>][j];</div><div class="line"><span class="keyword">else</span> &#123;</div><div class="line"><span class="comment">//否则，最大值在不放i物品和放i物品之间的价值抉择</span></div><div class="line">dpValue[i][j]=Math.max(dpValue[i-<span class="number">1</span>][j], (dpValue[i-<span class="number">1</span>][j-stuffArray[i].getWeight()]+stuffArray[i].getValue()));</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="空间复杂度优化"><a href="#空间复杂度优化" class="headerlink" title="空间复杂度优化"></a>空间复杂度优化</h3><p>如果我们仅仅是想得到最终的最大价值结果，而不用进行回溯的话，从数据依赖上看，我们对dp[i][j]的计算仅仅依赖于dp[i-1][j]和dp[i-1][j-w[i]],也就是在更新下标为j的时候仅仅依赖于小于等于j的值，那么我们完全可以使用一维数组来表示状态，而将更新的过程改为逆序的过程，保证在更新j的时候，小于等于j部分的值不被更改，这样的话整个空间复杂度就降成一维数组，改进后的算法技巧主要在第二个循环，我们注意看算法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">输入：背包容量C，物品个数num，以及每个物品的重量w[i],价值v[i]</div><div class="line">输出：当背包容量为C时候的最大价值</div><div class="line">置dp[j]全为0，j&lt;=C</div><div class="line">对于第i个物品，i&lt;=num,做如下循环</div><div class="line">对于容量j从C开始，j&gt;=w[i],做如下循环</div><div class="line">dp[j]=max&#123;dp[j],dp[j-w[i]]+v[i]&#125;</div><div class="line">返回dp[C]即为当背包容量为C时候的最大值</div></pre></td></tr></table></figure></p><p>在j&lt;w[i]的时候，保留原值，相当于dp[i][j]=dp[i-1][j]。</p><h2 id="0-1背包要求背包装满"><a href="#0-1背包要求背包装满" class="headerlink" title="0-1背包要求背包装满"></a>0-1背包要求背包装满</h2><p>如果要求背包必须装满时候的最大价值，那么初始状态dp[0][j]只有dp[0][0]为0，其他状态为不存在状态，只有依赖于存在状态的价值才是可计算的，其他为不可计算，那么我们的算法改为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">输入：背包容量C，物品个数num，以及每个物品的重量w[i],价值v[i]</div><div class="line">输出：当背包容量为C时候的最大价值</div><div class="line">置dp[0][0]为0，其他dp[0][j]=-1, j&lt;=C</div><div class="line">对于第i个物品，i&lt;=num,做如下循环</div><div class="line">对于容量j从0开始，j&lt;=C,做如下循环</div><div class="line">如果j&lt;w[i],则dp[i][j]=dp[i-1][j]</div><div class="line">如果dp[i-1][j-w[i]]==-1,则dp[i][j]=dp[i-1][j]</div><div class="line">否则，dp[i][j]=max&#123;dp[i-1][j],dp[i-1][j-w[i]]+v[i]&#125;</div><div class="line">返回dp[num][C]不为-1即为当背包容量为C时候的最大值</div></pre></td></tr></table></figure></p><p>以上面的例子来看状态数组的更新过程，最终的回溯必然回到dp[0][0]，并且这个过程同样可以使用滚动数组。<br><img src="https://i.imgur.com/bat5iUp.png" alt=""></p><h2 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h2><p>完全背包问题同样是有N种物品和一个容量为C的背包，和0-1背包不同的是每种物品的个数是无限个。这种情况下，其实我们可以将完全背包问题转换成0-1背包问题，不过这会增大循环的过程，使得算法复杂度升高。我们考虑使用另一种方法。<br>在上面的空间优化过的0-1背包问题中，我们在第二个循环中，使用了倒序更新的方式，原因是我们在要保证上一层更新dp[j]和dp[j-w[i]]是和dp[i-1][j],dp[i-1][j-w[i]],而当每个物品的个数是无限制的情况下，我们的更新需要依赖于我们当前的更新状态，一个大容量的背包可能同时放入多个当前物品。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">---原来的0-1背包算法---</div><div class="line">输入：背包容量C，物品个数num，以及每个物品的重量w[i],价值v[i]</div><div class="line">输出：当背包容量为C时候的最大价值</div><div class="line">置dp[j]全为0，j&lt;=C</div><div class="line">对于第i个物品，i&lt;=num,做如下循环</div><div class="line">对于容量j从C开始，j&gt;=w[i],做如下循环//倒序更新</div><div class="line">dp[j]=max&#123;dp[j],dp[j-w[i]]+v[i]&#125;</div><div class="line">返回dp[C]即为当背包容量为C时候的最大值</div></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">---完全背包算法---</div><div class="line">输入：背包容量C，物品个数num，以及每个物品的重量w[i],价值v[i]</div><div class="line">输出：当背包容量为C时候的最大价值</div><div class="line">置dp[j]全为0，j&lt;=C</div><div class="line">对于第i个物品，i&lt;=num,做如下循环</div><div class="line">对于容量j从0开始，j&lt;=w[i],做如下循环//正序更新</div><div class="line">dp[j]=max&#123;dp[j],dp[j-w[i]]+v[i]&#125;</div><div class="line">返回dp[C]即为当背包容量为C时候的最大值</div></pre></td></tr></table></figure><p>这相当于什么意思呢，相当于二维数组的时候更新的时候dp[i][j]=max{dp[i-1][j],dp[i][j-w[i]]+v[i]},也就是每次更新的值依赖于前面的值，而不是dp[i-1][j-w[i]]+v[i],也就是可以重复放入一个物品，如果使用二维数组解决上面的例子的完全背包问题，我们会得到这样一个状态数组。可以看到，第一个物品被重复放了5次。<br><img src="https://i.imgur.com/qybBE94.png" alt=""></p><h2 id="多重背包问题"><a href="#多重背包问题" class="headerlink" title="多重背包问题"></a>多重背包问题</h2><p>多重背包问题是介于0-1背包和完全背包问题之间，多重背包的每个物品的数量是有限的，是介于1到无限之间的某个数。当然我们仍然可以使用0-1背包问题来解决，假设我们有N种物品，第i个物品的个数是ki,背包容量是C，那我们的时间复杂度就变成了C*(所有k的和)。<br>如果想要削减时间复杂度，一种方法是将每个k按二进制切分，比如如果数量是7，我们切分成1,2,4三种物品，然后用0-1背包的问题进行求解，这样，时间复杂度就变成了C*(所有log(k)的和)。这样划分可以的原因在于我们可以用通过二进制换分的组合表示一个这个数范围内的所有数。</p><h2 id="二维费用背包问题"><a href="#二维费用背包问题" class="headerlink" title="二维费用背包问题"></a>二维费用背包问题</h2><p>背包问题的另一个变种是在背包容量和物品重量上的扩展，比如背包容量有两个维度[V,U],比如分别代表体积和重量，而物品的重量也是两个维度[C,D],其实我们仍然可以用前面的思路，不过现在容量变成了二维，而我们的状态数组也变成了三维dp[i][v][u],代表当前i个物品放入背包体积为v和重量为u的情况下的最大价值。转移方程当然也变成了，如果Ci&lt;v或者Di&lt;u,那么dp[i][v][u]=dp[i-1][v][u],否则，dp[i][v][u]=max{dp[i-1][v][u],dp[i-1][v-Ci][u-Di]+V[i]]。结束，当然，我们仍然可以使用空间优化将数组优化到二维数组。</p><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>本文首发表于<a href="https://buwenqi.github.io" target="_blank" rel="external">我的博客</a>,欢迎关注！已委托维权骑士为本站的文章进行维权，转载须注明文章出处，作者保留文章所有权。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;背包问题是经典动态规划思想的应用实例。其基本问题是:在拥有一个固定容量的背包的情况下，如何选择不同体积并且价值不同的物品装入背包中，使得背包中的物品的价值最大。也就是说物品有两个维度的属性：体积和价值，而背包限制了总体积。针对这个问题，衍生出不同的背包问题。&lt;br&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Spring学习笔记之bean的生命周期</title>
    <link href="http://yoursite.com/2018/06/21/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8Bbean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>http://yoursite.com/2018/06/21/Spring学习笔记之bean的生命周期/</id>
    <published>2018-06-21T01:39:00.000Z</published>
    <updated>2018-08-06T00:59:20.370Z</updated>
    
    <content type="html"><![CDATA[<p>理解spring bean的生命周期对于细粒度的控制bean的创建、使用和销毁具有重要的意义，比如我们想要在一个bean创建之后做些额外的操作，合理的使用spring在生命周期中的调用方法，就可以轻易的完成这个任务，不过，首先，我们要理解bean在整个生命周期调用的方法链，才能正确的完成所需的功能。本文的目的是尝试使用实验的方式探索一个bean的生命周期。<br><a id="more"></a><br>我们首先创建一个bean类，它实现了InitializingBean,DisposableBean接口中的方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> org.springframework.beans.factory.DisposableBean;</div><div class="line"><span class="keyword">import</span> org.springframework.beans.factory.InitializingBean;</div><div class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</div><div class="line"></div><div class="line"><span class="keyword">import</span> javax.annotation.PostConstruct;</div><div class="line"><span class="keyword">import</span> javax.annotation.PreDestroy;</div><div class="line"></div><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span>,<span class="title">DisposableBean</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123;<span class="comment">//无参构造方法</span></div><div class="line">        System.out.println(<span class="string">"Constructor"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.name=name;<span class="comment">//属性注入</span></div><div class="line">        System.out.println(<span class="string">"Property Setter"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@PostConstruct</span><span class="comment">//javax中PostConstruct注解</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postConstruct</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"PostConstruct"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span><span class="comment">//InitializingBean接口方法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        System.out.println(<span class="string">"InitializingBean: afterPropertiesSet"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initMethod</span><span class="params">()</span></span>&#123;<span class="comment">//init-method标签方法</span></div><div class="line">        System.out.println(<span class="string">"init-method"</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@PreDestroy</span><span class="comment">//javax中PreDestroy注解</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preDestroy</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"preDestroy"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;<span class="comment">//DisposableBean接口方法</span></div><div class="line">        System.out.println(<span class="string">"DisposableBean: destroy"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroyMethod</span><span class="params">()</span></span>&#123;<span class="comment">//destroy-method标签方法</span></div><div class="line">        System.out.println(<span class="string">"destroy-method"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>我们在spring配置文件中加载此bean,并且配置了init-method和destroy-method<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"person"</span> <span class="attr">class</span>=<span class="string">"wenqi.bean.Person"</span> <span class="attr">init-method</span>=<span class="string">"initMethod"</span> <span class="attr">destroy-method</span>=<span class="string">"destroyMethod"</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"wenqi"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line"> <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure></p><p>在我们使用ClassPathXmlApplicationContext加载配置文件后，并在执行后使用close方法关闭ClassPathXmlApplicationContext后，得到如下输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Constructor</div><div class="line">Property Setter</div><div class="line">PostConstruct</div><div class="line">InitializingBean: afterPropertiesSet</div><div class="line">init-method</div><div class="line"></div><div class="line">preDestroy</div><div class="line">DisposableBean: destroy</div><div class="line">destroy-method</div></pre></td></tr></table></figure></p><p>可见，在bean的生命周期里，构造方法首先被执行，然后如果有属性注入，则调用方法进行属性注入，属性注入完成后，PostConstruct注解的方法被执行，然后是InitializingBean的afterPropertiesSet方法被执行，而后，init-method方法的标签被执行，之后，bean就处于可被使用的状态。当调用了ClassPathXmlApplicationContext的close之后，则依次调用PreDestroy注解方法，DisposableBean的destroy方法，destroy-method标签中指定的方法。<br>总结一下，整个调用过程就是Constructor-&gt;Setter-&gt;PostConstruct-&gt;InitializingBean:AfterPropertiesSet-&gt;(init-method)-&gt;使用中-&gt;(容器关闭)-&gt;PreDestroy方法-&gt;Disposable:destroy方法-&gt;(destroy-method)。<br>其中PostConstruct，PreDestroy注解方法是javax中注解，可见jdk中的基础注解方法会在spring的方法之前调用，接着是InitializingBean和DisposableBean的方法会在标签方法之前执行。（PostConstruct，PreDestroy需要配置context:annotation-config）<br>理解了执行顺序，如果我们想在实例化之后进行一些操作，既可以使用PostConstruct注解方法，也可以使用InitializingBean中的方法。</p><h2 id="加上BeanPostProcessor"><a href="#加上BeanPostProcessor" class="headerlink" title="加上BeanPostProcessor"></a>加上BeanPostProcessor</h2><p>如果我们实现了一个BeanPostProcessor的子类，并且将它注册在spring配置文件中，那么这个接口的postProcessBeforeInitialization和postProcessAfterInitialization方法会在属性注入之后（PostConstruct之后）和PreDestroy之前执行。这个类是全局的，也就是说它会在所有的bean实例化之后和销毁之前执行对应的方法。例如，我们注册了一个自定义的BeanPostProcessor。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</div><div class="line">        System.out.println(<span class="string">"MyBeanPostProcessor: postProcessBeforeInitialization,beanName: "</span>+beanName);</div><div class="line">        <span class="keyword">return</span> bean;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</div><div class="line">        System.out.println(<span class="string">"MyBeanPostProcessor: postProcessAfterInitialization,beanName: "</span>+beanName);</div><div class="line">        <span class="keyword">return</span> bean;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>注册该BeanPostProcessor，我们再次加载上面的bean，得到的结果是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Constructor</div><div class="line">Property Setter</div><div class="line">**MyBeanPostProcessor: postProcessBeforeInitialization,beanName: person**</div><div class="line">PostConstruct</div><div class="line">InitializingBean: afterPropertiesSet</div><div class="line">init-method</div><div class="line"></div><div class="line">**MyBeanPostProcessor: postProcessAfterInitialization,beanName: person**</div><div class="line">preDestroy</div><div class="line">DisposableBean: destroy</div><div class="line">destroy-method</div></pre></td></tr></table></figure></p><p>也就是说会在属性注入后和销毁前环绕执行postProcessBeforeInitialization和postProcessAfterInitialization，那么如果有多个BeanPostProcessor,结果会是怎样呢，我们多注册一个MyBeanPostProcessor2，它的处理逻辑是一样的，只不过打印的头信息不同，输出结果编程这样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Constructor</div><div class="line">Property Setter</div><div class="line">**MyBeanPostProcessor: postProcessBeforeInitialization,beanName: person**</div><div class="line">**MyBeanPostProcessor2: postProcessBeforeInitialization,beanName: person**</div><div class="line">PostConstruct</div><div class="line">InitializingBean: afterPropertiesSet</div><div class="line">init-method</div><div class="line"></div><div class="line">**MyBeanPostProcessor: postProcessAfterInitialization,beanName: person**</div><div class="line">**MyBeanPostProcessor2: postProcessAfterInitialization,beanName: person**</div><div class="line">preDestroy</div><div class="line">DisposableBean: destroy</div><div class="line">destroy-method</div></pre></td></tr></table></figure></p><p>结论是依次按照配置文件里的顺序执行postProcessBeforeInitialization然后执行初始化后的方法，接着销毁前按顺序执行postProcessAfterInitialization，接着执行销毁方法。<br>有多个bean，那么BeanPostProcessor会环绕执行每一个bean。</p><h2 id="xxxAware接口注入上下文相关对象"><a href="#xxxAware接口注入上下文相关对象" class="headerlink" title="xxxAware接口注入上下文相关对象"></a>xxxAware接口注入上下文相关对象</h2><p>另外，Spring生命周期中还提供了注入上下文相关对象的接口，这种接口一般被命名为xxxAware,它们提供的对应的setter方法,将与上下文相关的信息在属性注入后注入到bean对象中使用，上下文相关的信息如：bean的名字，bean创建工厂，bean的上下文对象，这三个常用的上下文相关对象由BeanNameAware,BeanFactoryAware,ApplicationContextAware来完成，只要bean实现对应的接口方法，那么在属性注入后，spring就会将bean的名字(由id属性定义)，创建工厂，上下文对象会分别传入这些方法。其中这三个方法的执行属性一次是setBeanName，setBeanFactory，setApplicationContext。ApplicationContext是基于BeanFactory实现的，提供了比建造工厂更多的功能，如读取xml配置文件，设置监听注册等等。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanName</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">       System.out.println(<span class="string">"BeanNameAware setBeanName:"</span>+s);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanFactory</span><span class="params">(BeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</div><div class="line">       System.out.println(<span class="string">"BeanFactoryAware setBeanFactory:"</span>+beanFactory);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException </span>&#123;</div><div class="line">       System.out.println(<span class="string">"ApplicationContext setApplicationContext:"</span>+applicationContext);</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p><p>添加了这三个接口方法后，我们再执行，得到的结果是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Constructor</div><div class="line">Property Setter</div><div class="line">**BeanNameAware setBeanName:dd**</div><div class="line">**BeanFactoryAware setBeanFactory**</div><div class="line">**ApplicationContext setApplicationContext**</div><div class="line">MyBeanPostProcessor: postProcessBeforeInitialization,beanName: dd</div><div class="line">PostConstruct</div><div class="line">InitializingBean: afterPropertiesSet</div><div class="line">init-method</div><div class="line">MyBeanPostProcessor: postProcessAfterInitialization,beanName: dd</div><div class="line">preDestroy</div><div class="line">DisposableBean: destroy</div><div class="line">destroy-method</div></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后，总结整个spring bean的生命周期，可以将其分为四个大块：构造方法，属性注入，初始化方法，销毁方法。其中，属性注入的顺序是bean属性注入，BeanNameAware注入，BeanFactoryAware注入，ApplicationContextAware注入。初始化方法和销毁方法是一一对应的，如初始化方法的顺序是BeanPostProcessor的postProcessBeforeInitialization,javax注解PostConstruct,InitializingBean的afterPropertiesSet,标签方法init-method。<br>对应的BeanPostProcessor的postProcessAfterInitialization,javax注解preDestroy，DisposableBean的destroy，标签方法destroy-method。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="http://www.cnblogs.com/sishang/p/6575839.html" target="_blank" rel="external">Spring点滴四：Spring Bean生命周期</a><br><a href="https://blog.csdn.net/lisongjia123/article/details/52091013" target="_blank" rel="external">SpringBean生命周期详解</a><br><a href="https://blog.csdn.net/chenlong220192/article/details/46723561" target="_blank" rel="external">Spring中<context:annotation-config>的作用</context:annotation-config></a></p><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>本文首发表于<a href="https://buwenqi.github.io" target="_blank" rel="external">我的博客</a>,欢迎关注！已委托维权骑士为本站的文章进行维权，转载须注明文章出处，作者保留文章所有权。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;理解spring bean的生命周期对于细粒度的控制bean的创建、使用和销毁具有重要的意义，比如我们想要在一个bean创建之后做些额外的操作，合理的使用spring在生命周期中的调用方法，就可以轻易的完成这个任务，不过，首先，我们要理解bean在整个生命周期调用的方法链，才能正确的完成所需的功能。本文的目的是尝试使用实验的方式探索一个bean的生命周期。&lt;br&gt;
    
    </summary>
    
    
      <category term="spring" scheme="http://yoursite.com/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>Java并发系列笔记之阻塞队列</title>
    <link href="http://yoursite.com/2018/06/10/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%E4%B9%8B%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/"/>
    <id>http://yoursite.com/2018/06/10/Java并发系列笔记之阻塞队列/</id>
    <published>2018-06-10T01:39:00.000Z</published>
    <updated>2018-08-06T00:59:10.474Z</updated>
    
    <content type="html"><![CDATA[<p>阻塞队列是Java并发中重要的并发容器，而且这个并发容器首先是队列，提供队列FIFO的特性，而且是这个队列是具有阻塞特性的，也就是说在队列满和队列空的情况下，会对添加线程和获取线程进行阻塞，以等待相应的同步状态释放，方法才得以返回。这种特性大有用武之地，比如典型的并发问题，生产者消费者问题，就可以将这种阻塞队列抽象出来，实现一种具有并发控制的容器，作为一种新的数据结构提供给应用层使用。<br><a id="more"></a><br>JDK提供了多种阻塞队列的实现，常用的如ArrayBlockingQueue，LinkedBlockingQueue等等，本文致力于研究JDK中的阻塞队列的具体实现，并且学习其设计思路。</p><h2 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h2><p>ArrayBlockingQueue中有三对方法：</p><ol><li>boolean add(E e),E remove(),这两个方法分别是添加元素到队尾，删除队头的元素，如果队列已满或者队列空的情况下抛出异常，这两个方法继承自父类Queue的实现。</li><li>boolean offer(E e),E poll(),这两个方法也是实现添加元素到队尾，删除队头的元素，但是在队列已满或者空的情况下不抛出异常，而是返回false，在添加或者删除的时候进行了加锁控制</li><li>void put(E e),E take(),功能同以上，但是在队列满的时候，put方法会阻塞，直至有take方法将其唤醒，同样的，当队列为空的时候，take方法也会阻塞，直到put方法将其唤醒。</li></ol><p>我们重点来看put和take方法的阻塞实现，他们使用了可重入锁ReentrantLock，并且使用Condition来控制入队和出队线程。如图，ArrayBlockingQueue的构造方法会初始化ReentrantLock，并且会初始化两个Condition对象。<br><img src="https://i.imgur.com/1OgcqLj.png" alt=""><br>put方法在插入的时候加锁，并且尝试判断当前队列是否已满，如果满了，则调用notFull Condition的await方法阻塞，使用while循环的原因是当返回的时候还要检查一遍。最后进行入队操作，并且唤醒notEmpty Condition，解锁返回。<br><img src="https://i.imgur.com/MUNZUju.png" alt=""><br><img src="https://i.imgur.com/0kjGqHS.png" alt=""><br>take方法的过程是相似的，加锁后判断队列是否为空，如果为空的话，使用notEmpty阻塞，等待被唤醒，被唤醒后如果队列不为空，调用dequeue方法出队，在出队后唤醒notFull Condition。<br><img src="https://i.imgur.com/mdMSv1N.png" alt=""><br><img src="https://i.imgur.com/cFs1ZDY.png" alt=""></p><h2 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h2><p>LinkedBlockingQueue同样使用ReentrantLock进行并发控制，但是队列使用双向链表进行保存，并且持有首节点和尾节点的引用，并发控制逻辑和ArrayBlockingList类似</p><h2 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h2><p>PriorityBlocingQueue是一个按照优先级排序的无界队列，所谓无界队列是指默认容量无限大，进行put的时候不会进行阻塞，只在take的时候如果队列为空进行阻塞。<br>priorityBlockingQueue也是使用数组作为存储容器，并且容器内的元素按照堆的顺序进行排序，所有容器内的元素需要实现Comparable接口或者传入Comparator对象。<br>put方法直接调用了offer方法，其有几个关键步骤，首先判断是否需要扩容，使用tryGrow方法进行扩容，插入阶段调用siftUpComparable或者siftUpUsingComparator进行堆的上滤调整，最后唤醒notEmpty Conditon。<br><img src="https://i.imgur.com/c5iSUll.png" alt=""><br>take方法依旧需要阻塞，和ArrayBlockingQueue的方法类似，不过出队后要进行堆调整。<br><img src="https://i.imgur.com/TJhagxm.png" alt=""><br>PriorityBlockingQueue适合需要按照一定的排序规则获取队列中元素的任务。</p><h2 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h2><p>SynchronousQueue是一个不存储元素的阻塞队列，每个put必须等待一个take操作，否则不能继续添加元素，实现上使用TransferQueue的transfer放来完成传递，适合有大量消费者的情况使用，这样保证一直有消费者进行take操作，比如Excutors的newCachedThreadPool就使用了SynchronousQueue作为阻塞队列。<br><img src="https://i.imgur.com/ytB7kKF.png" alt=""><br><img src="https://i.imgur.com/Ghg9nRJ.png" alt=""></p><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>本文首发表于<a href="https://buwenqi.github.io" target="_blank" rel="external">我的博客</a>,欢迎关注！转载须注明文章出处，作者保留文章所有权。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;阻塞队列是Java并发中重要的并发容器，而且这个并发容器首先是队列，提供队列FIFO的特性，而且是这个队列是具有阻塞特性的，也就是说在队列满和队列空的情况下，会对添加线程和获取线程进行阻塞，以等待相应的同步状态释放，方法才得以返回。这种特性大有用武之地，比如典型的并发问题，生产者消费者问题，就可以将这种阻塞队列抽象出来，实现一种具有并发控制的容器，作为一种新的数据结构提供给应用层使用。&lt;br&gt;
    
    </summary>
    
    
      <category term="Java并发系列" scheme="http://yoursite.com/tags/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>解析Arrays中sort方法的黑科技</title>
    <link href="http://yoursite.com/2018/05/13/%E8%A7%A3%E6%9E%90Arrays%E4%B8%ADsort%E6%96%B9%E6%B3%95%E7%9A%84%E9%BB%91%E7%A7%91%E6%8A%80/"/>
    <id>http://yoursite.com/2018/05/13/解析Arrays中sort方法的黑科技/</id>
    <published>2018-05-13T01:39:00.000Z</published>
    <updated>2018-05-13T14:36:31.643Z</updated>
    
    <content type="html"><![CDATA[<p>排序问题是算法里面的经典问题，也是计算机学科数据结构课程里面的必修课，面对诸多的如插入排序，快速排序，堆排序，归并排序等等经典排序算法，JDK的实现者是如何选择排序算法的呢？我们经常使用的对数据进行排序的算法Arrays.sort，Collections.sort方法，那么具体它们是如何实现的呢，本文尝试从jdk 1.8的实现源码上进行分析，学习在实际工业环境下对排序算法的使用方法。<br><a id="more"></a></p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Collections的sort方法的实现最终调用了Arrays的sort方法，所以我们仅仅分析Arrays中的sort方法，这一节，我们尝试从宏观的角度来看Arrays的sort方法。Arrays的sort方法分为两种：基本类型和Object类型。他们的实现方法不同<br>我们从Arrays.sort(int[])方法来概述基本类型排序的基本思路：1.如果数组元素个数小于NSERTION_SORT_THRESHOLD(47),那么使用改进的插入排序进行排序，2.如果元素个数大于插入排序的阈值并且小于快速排序的阈值QUICKSORT_THRESHOLD(286)，则使用改进的双轴快速排序进行排序，3.如果元素个数大于快速排序的阈值，根据数组的无序程度来判定继续使用哪种算法，无序程度通过将数组划分为不同的有序序列的个数来判定，如果有序序列的个数大于MAX_RUN_COUNT(67),则认为原数组基本无序,则仍然使用双轴快速排序，如果小于MAX_RUN_COUNT，则认为原数组基本有序，使用归并排序进行排序。<br>我们从Arrays.sort(Object[])的实现来概述Object对象类型的排序，其基本思路是：1.如果数组元素个数小于MIN_MERGE(32),2.如果大于MIN_MERGE，则将数组划分成多个有序块进行归并排序。<br>综上所述，无论是基本类型的排序还是Object类型的排序，都使用了多种排序的组合，这种组合的原因在于在不同的排序规模下，需要适应性的选用不同的排序方法，例如，在排序规模较小的情况下，复杂度为O(n^2)的插入排序能获得比例如快速排序更好的排序性能，而在数组基本有序的情况下，归并排序比快速排序相比是更好的选择。总的来说，根据不同的数组规模决定使用不同的排序方法。接下来我们通过详细的代码分析其具体实现。</p><h2 id="基本类型排序-Arrays-sort-int"><a href="#基本类型排序-Arrays-sort-int" class="headerlink" title="基本类型排序(Arrays.sort(int[]))"></a>基本类型排序(Arrays.sort(int[]))</h2><p>Arrays的sort方法直接调用了DualQivotQuicksort的sort方法，类名的英语意思是双轴快速排序。可见双轴快速排序是关键。<br><img src="https://i.imgur.com/XcUJj46.png" alt=""><br>接下来进入sort方法，通过英语注释我们可以看到第一步，如果数组长度较小的话（小于QUICKSORT_THRESHOLD）,则使用sort方法进行排序，执行完方法结束。<br><img src="https://i.imgur.com/CG6ybCO.png" alt=""><br>那么sort方法又是如何排序的，判断数组长度是否小于INSERTION_SORT_THRESHOLD，如果是的话，则使用插入排序，并且在插入排序使用leftmost控制使用传统的插入排序还是改进的插入排序。改进的插入排序被称为成对插入排序（pair insertion sort）,其基本思想是一次取出两个未排序数组的元素，并且确保（a1&gt;a2）,那么在a1找到位置后，a2的位置肯定在a1之前，继续查找即可。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (length &lt; INSERTION_SORT_THRESHOLD) &#123;</div><div class="line">      <span class="keyword">if</span> (leftmost) &#123;<span class="comment">//默认情况下，经典插入排序</span></div><div class="line">          <span class="comment">/*</span></div><div class="line">           * Traditional (without sentinel) insertion sort,</div><div class="line">           * optimized for server VM, is used in case of</div><div class="line">           * the leftmost part.</div><div class="line">           */</div><div class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = left, j = i; i &lt; right; j = ++i) &#123;</div><div class="line">              <span class="keyword">int</span> ai = a[i + <span class="number">1</span>];</div><div class="line">              <span class="keyword">while</span> (ai &lt; a[j]) &#123;</div><div class="line">                  a[j + <span class="number">1</span>] = a[j];</div><div class="line">                  <span class="keyword">if</span> (j-- == left) &#123;</div><div class="line">                      <span class="keyword">break</span>;</div><div class="line">                  &#125;</div><div class="line">              &#125;</div><div class="line">              a[j + <span class="number">1</span>] = ai;</div><div class="line">          &#125;</div><div class="line">      &#125; <span class="keyword">else</span> &#123;<span class="comment">//否则，使用改进后的成对插入排序</span></div><div class="line">          <span class="comment">/*</span></div><div class="line">           * Skip the longest ascending sequence.</div><div class="line">           */</div><div class="line">          <span class="keyword">do</span> &#123;</div><div class="line">              <span class="keyword">if</span> (left &gt;= right) &#123;</div><div class="line">                  <span class="keyword">return</span>;</div><div class="line">              &#125;</div><div class="line">          &#125; <span class="keyword">while</span> (a[++left] &gt;= a[left - <span class="number">1</span>]);</div><div class="line"></div><div class="line">          <span class="comment">/*</span></div><div class="line">           * Every element from adjoining part plays the role</div><div class="line">           * of sentinel, therefore this allows us to avoid the</div><div class="line">           * left range check on each iteration. Moreover, we use</div><div class="line">           * the more optimized algorithm, so called pair insertion</div><div class="line">           * sort, which is faster (in the context of Quicksort)</div><div class="line">           * than traditional implementation of insertion sort.</div><div class="line">           */</div><div class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> k = left; ++left &lt;= right; k = ++left) &#123;</div><div class="line">              <span class="keyword">int</span> a1 = a[k], a2 = a[left];</div><div class="line"></div><div class="line">              <span class="keyword">if</span> (a1 &lt; a2) &#123;</div><div class="line">                  a2 = a1; a1 = a[left];</div><div class="line">              &#125;</div><div class="line">              <span class="keyword">while</span> (a1 &lt; a[--k]) &#123;</div><div class="line">                  a[k + <span class="number">2</span>] = a[k];</div><div class="line">              &#125;</div><div class="line">              a[++k + <span class="number">1</span>] = a1;</div><div class="line"></div><div class="line">              <span class="keyword">while</span> (a2 &lt; a[--k]) &#123;</div><div class="line">                  a[k + <span class="number">1</span>] = a[k];</div><div class="line">              &#125;</div><div class="line">              a[k + <span class="number">1</span>] = a2;</div><div class="line">          &#125;</div><div class="line">          <span class="keyword">int</span> last = a[right];</div><div class="line"></div><div class="line">          <span class="keyword">while</span> (last &lt; a[--right]) &#123;</div><div class="line">              a[right + <span class="number">1</span>] = a[right];</div><div class="line">          &#125;</div><div class="line">          a[right + <span class="number">1</span>] = last;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span>;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p><p>如果不是小于INSERTION_SORT_THRESHOLD，则使用5分位法找出5个位置的值做双轴快速排序<br><img src="https://i.imgur.com/IuY4k4r.png" alt=""><br>这里有必要解释一下双轴快速排序，双轴快速排序的思想是相对于单轴快速排序，经典的单轴快速排序，每次选择一个元素作为轴值pivot,然后使用双指针将小于pivot移到pivot的左边，大于pivot的值移到右边，使得pivot处于最终位置，这个过程称为一次排序，对两边递归的调用一次排序可以得到最终的排序结果。<br>而双轴快速排序的基本思想是一次可以将两个元素放到最终位置上，假设这两个轴值为pivot1,pivot2,那么一次排序后，最终数组被这两个元素划分成三块：&lt;pivot1, &gt;=pivot1并且&lt;=pivot2, &gt;pivot2。为了达到这种划分，我们需要三个指针来进行操作i,k,j,i左边的是小于pivot1的，j右边的是大于pivot1的，k用来扫描，当k和j相聚的时候，则扫描结束。关于双轴快速排序的具体实现可以参考这篇文章《<a href="https://blog.csdn.net/holmofy/article/details/71168530#t7" target="_blank" rel="external">单轴快排（SinglePivotQuickSort）和双轴快排（DualPivotQuickSort）及其JAVA实现</a>》这篇文章，写的很好。<br>相比单轴快速排序，双轴快速排序能够获取更快的排序效率，我们来看一看源码中的关键实现，从源码上来看，当5分位点所有值都不相同的时候，选取第二个点和第四个点作为双轴进行双轴快速排序。<br><img src="https://i.imgur.com/a9F803z.png" alt=""><br><img src="https://i.imgur.com/VLJ2sEg.png" alt=""><br>否则的话，就使用第三个点进行单轴快速排序<br><img src="https://i.imgur.com/SrhuB9L.png" alt=""><br>以上是数组长度小于QUICKSORT_THRESHOLD（286）时候的排序策略，如果大于这个快速排序的阈值，又是怎么做的呢，我们继续往下看源码，发现这么一段代码，其目的也很明确，就是检查原来数组是不是基本有序，方法是找出有序的数组片段，用count进行统计，如果count一旦等于MAX_RUN_COUNT，则认为基本无序，使用我们上面提到的方法进行快速排序。<br><img src="https://i.imgur.com/Y0x0e38.png" alt=""><br>基本无序状态检查<br><img src="https://i.imgur.com/aDAA6Hd.png" alt=""><br>在上面统计count的过程中，同样使用run数组记录所有的基本有序的数组的最后一个元素的下标，如果判定结果是基本有序，则使用的归并排序进行最终的排序，方法是通过run方法记录的下标每次合并两个有序序列，最终使得数组有序，这里就不贴出很长的归并代码。<br>基本上，基础类型的排序算法就这样讲完了。</p><h2 id="Object类型排序-Arrays-sort-Object"><a href="#Object类型排序-Arrays-sort-Object" class="headerlink" title="Object类型排序(Arrays.sort(Object[]))"></a>Object类型排序(Arrays.sort(Object[]))</h2><p>Arrays.sort方法的Object数组要求实现Comparable接口，因为在其实现过程中有<br>Object类型的排序中legacyMergeSort是经典的归并排序，不过它即将被废弃了，这里只是用来兼容老的排序方法，现在默认使用的是ComparableSort里面的sort方法，我们的分析着重在这个方法。<br><img src="https://i.imgur.com/jannld8.png" alt=""><br>首先，如果数组的长度小于MIN_MERGE(32),那么就会调用二分插入排序binarySort方法进行排序，所谓二分排序，是指在插入的过程中，使用二分查找的方法查找待插入的位置，这种查找方法会比线性查找快一点。<br><img src="https://i.imgur.com/VEjp9yM.png" alt=""><br>如果不答应MIN_MERGE，则使用归并排序，归并的方法是将数组换分成等块的小数组(除最后一块)，在小数组内进行二分插入排序，排序后将当前数组的初始位置，长度使用pushRun方法压栈，mergeCollapse方法每次会从数组中取出两个小数组进行归并排序，最终循环结束后，数组也已经排序完成。<br><img src="https://i.imgur.com/UHpzukl.png" alt=""><br>嗯，基本上就是这样了</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://zongwenlong.github.io/2017/01/06/Java-SourceCode-Sort/" target="_blank" rel="external">Java源码阅读-DualPivotQuicksort</a><br><a href="https://blog.csdn.net/octopusflying/article/details/52388012" target="_blank" rel="external">数据数组排序：Arrays.sort()</a><br><a href="https://blog.csdn.net/holmofy/article/details/71168530#t7" target="_blank" rel="external">单轴快排（SinglePivotQuickSort）和双轴快排（DualPivotQuickSort）及其JAVA实现</a><br><a href="https://blog.csdn.net/qq_16403141/article/details/78234868" target="_blank" rel="external">Arrays.sort()方法的源码分析</a></p><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>本文首发表于<a href="https://buwenqi.github.io" target="_blank" rel="external">我的博客</a>,欢迎关注！已委托维权骑士为本站的文章进行维权，转载须注明文章出处，作者保留文章所有权。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;排序问题是算法里面的经典问题，也是计算机学科数据结构课程里面的必修课，面对诸多的如插入排序，快速排序，堆排序，归并排序等等经典排序算法，JDK的实现者是如何选择排序算法的呢？我们经常使用的对数据进行排序的算法Arrays.sort，Collections.sort方法，那么具体它们是如何实现的呢，本文尝试从jdk 1.8的实现源码上进行分析，学习在实际工业环境下对排序算法的使用方法。&lt;br&gt;
    
    </summary>
    
    
      <category term="Java基础" scheme="http://yoursite.com/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java并发系列笔记之并发容器ConcurrentHashMap</title>
    <link href="http://yoursite.com/2018/05/08/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8ConcurrentHashMap/"/>
    <id>http://yoursite.com/2018/05/08/Java并发系列笔记之并发容器ConcurrentHashMap/</id>
    <published>2018-05-08T01:39:00.000Z</published>
    <updated>2018-05-09T08:08:08.647Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线程不安全的HashMap"><a href="#线程不安全的HashMap" class="headerlink" title="线程不安全的HashMap"></a>线程不安全的HashMap</h2><p>多线程情况下，HashMap由于在扩容的时候会导致链变成环，在下一次查询的时候会使得出现死循环的出现。变成环的主要原因在于HashMap扩容的逻辑是不具有原子性的，扩容的基本逻辑包括下面三条：</p><ol><li>当前节点为e，获取当前节点的下一个节点next</li><li>将e按照hash移到到扩容后的hash表中，置e.next等于newtable[i],头插法</li><li>将e置为next进入下一次循环</li></ol><a id="more"></a><p>这个过程在单线程中没有问题，如果原来hash值相同的值在新的hash表中仍然相同，假设原来的链表为A-B,那么走完第一步e为A,next为B，此时该线程挂起，另一个线程进入，执行完以上三步后newtable[i]中的链表为B-A,如果第一个线程继续执行，则会使A.next指向newtable[i],而newtable[i]是B-A，此时明显出现了环。而下一次遍历该链表的时候，会出现死循环。</p><h2 id="volatile和CAS"><a href="#volatile和CAS" class="headerlink" title="volatile和CAS"></a>volatile和CAS</h2><p>volatile保证可见性是指：volatile变量读取的始终是内存中最后写入的值，volatile变量的写入会使其他线程工作内存的变量失效。也就是说只保证get这个值的时候返回的是内存中的值，保证修改单一变量时候的原子性，但不保证复合操作的原子性，复合操作有可能还在使用旧值进行操作，如i++。Java只保证了基本数据类型的变量和赋值操作才是原子性的，如i=1。<br>CAS则是使用预期值判断内存中的值是否一致，如果一致则进行修改，否则修改失败，整个读取-对比-写入是原子操作。CAS是一种高效的乐观锁技术，它被广泛使用在jdk的并发实现中。<br>使用CAS轮询和volatile类型状态变量，可以实现轻量级的乐观锁技术。</p><h2 id="线程安全的ConcurrentHashMap"><a href="#线程安全的ConcurrentHashMap" class="headerlink" title="线程安全的ConcurrentHashMap"></a>线程安全的ConcurrentHashMap</h2><p>jdk1.7和jdk1.8中的ConcurrentHashMap实现有了较大的区别，其中jdk1.7中使用分段锁的Segment实现，而jdk1.8则使用CAS+synchronized相结合的方式</p><h2 id="jdk1-7中的ConcurrentHashMap关键方法"><a href="#jdk1-7中的ConcurrentHashMap关键方法" class="headerlink" title="jdk1.7中的ConcurrentHashMap关键方法"></a>jdk1.7中的ConcurrentHashMap关键方法</h2><h3 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h3><p>put的基本思想是将根据hash的高位获取Segment的下标(如果Segment数组是16，则取高4位)，然后获取锁，使用ReentrantLock的trylock方法获取锁，如果获取成功，首先会是否超过负载值，如果超过了，就进行扩容，否则，直接插入，扩容的过程是在Segment的内部进行的，扩容会将数组扩大两倍。</p><h3 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h3><p>get也是首先获取Segment，然后在Segment的HashEntry数组的(hash &amp; tablesize-1)下标下进行查找。</p><h3 id="size方法"><a href="#size方法" class="headerlink" title="size方法"></a>size方法</h3><p>size方法的基本策略是将所有Segment中count相加，但是这样会导致不准确，jdk的做法是首先直接统计两次，如果两次相同，则成功，如果失败，则将所有的segment加锁统计。</p><h2 id="jdk1-8中ConcurrentHashMap实现要点"><a href="#jdk1-8中ConcurrentHashMap实现要点" class="headerlink" title="jdk1.8中ConcurrentHashMap实现要点"></a>jdk1.8中ConcurrentHashMap实现要点</h2><h3 id="关键数据结构"><a href="#关键数据结构" class="headerlink" title="关键数据结构"></a>关键数据结构</h3><p>Node,用来包装基本的hash,key,value值。<br>TreeNode树节点，确切的说是红黑树节点，继承了Node，用来作为TreeBin红黑树的节点，<br>ForwardingNode,继承自Node,其hash为-1，用来在扩容时指示当前节点已经完成转移。<br>其中ConcurrentHashMap维护一个Node的数组，在非扩容阶段，只有Node和TreeBin节点，扩容阶段会出现ForwardingNode</p><h3 id="CAS的使用"><a href="#CAS的使用" class="headerlink" title="CAS的使用"></a>CAS的使用</h3><p>除了对状态变量的更新使用到的CAS，对Node数组的操作也是包含了三个核心CAS方法，分别是获取数组的第i个元素，替换数组中的第i个元素，设置数组中第i个位置的值。<br><img src="https://i.imgur.com/chIJPq5.png" alt=""></p><h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><p>扩容的时机是在容量超过负载的时候进行的，这段逻辑在插入一个元素并且统计总数的方法里面实现的。jdk1.8的扩容和之前不一样之处在于允许多个线程参与扩容过程。其基本过程如下</p><ol><li>如果newTable为空，则创建一个原来两倍的数组。</li><li>将table中的数据复制到newTable中，可以多线程操作，</li><li>复制阶段，如果遍历的节点为forward节点，则说明此节点已经复制过，调到下一个节点</li><li>如果节点不为forward节点，则使用synchronized对节点加锁，并且复制这个链表或者树到i或者i+n位置</li><li>复制结束后将table指向newtable</li></ol><h3 id="put方法要点总结"><a href="#put方法要点总结" class="headerlink" title="put方法要点总结"></a>put方法要点总结</h3><p>put方法主要有四个大的判断逻辑，也就是主要的四步</p><ol><li>table是否为空，如果为空的话，则初始化表</li><li>如果table不为空，则查看(n-1)&amp;hash位置的值是否为null,如果为null的话，CAS插入待插入节点，插入结束</li><li>如果遍历到的节点为forward节点，则使用helpTransfer方法帮助其扩容，helpTransfer会调用扩容的transfer方法</li><li>否则的话，将当前遍历的节点加锁，根据是Node还是TreeBin执行不同的插入逻辑，如果链表的长度大于阈值，则将其转换成红黑树</li><li>最后调用addCount方法将ConcurrentHashMap的size+1</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> putVal(key, value, <span class="keyword">false</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/** Implementation for put and putIfAbsent */</span></div><div class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());</div><div class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</div><div class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</div><div class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</div><div class="line">            tab = initTable();</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</div><div class="line">                         <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</div><div class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</div><div class="line">            tab = helpTransfer(tab, f);</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            V oldVal = <span class="keyword">null</span>;</div><div class="line">            <span class="keyword">synchronized</span> (f) &#123;</div><div class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</div><div class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</div><div class="line">                        binCount = <span class="number">1</span>;</div><div class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</div><div class="line">                            K ek;</div><div class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</div><div class="line">                                ((ek = e.key) == key ||</div><div class="line">                                 (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</div><div class="line">                                oldVal = e.val;</div><div class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</div><div class="line">                                    e.val = value;</div><div class="line">                                <span class="keyword">break</span>;</div><div class="line">                            &#125;</div><div class="line">                            Node&lt;K,V&gt; pred = e;</div><div class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</div><div class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</div><div class="line">                                                          value, <span class="keyword">null</span>);</div><div class="line">                                <span class="keyword">break</span>;</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</div><div class="line">                        Node&lt;K,V&gt; p;</div><div class="line">                        binCount = <span class="number">2</span>;</div><div class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</div><div class="line">                                                       value)) != <span class="keyword">null</span>) &#123;</div><div class="line">                            oldVal = p.val;</div><div class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</div><div class="line">                                p.val = value;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</div><div class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</div><div class="line">                    treeifyBin(tab, i);</div><div class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</div><div class="line">                    <span class="keyword">return</span> oldVal;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    addCount(<span class="number">1L</span>, binCount);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="get方法要点"><a href="#get方法要点" class="headerlink" title="get方法要点"></a>get方法要点</h3><p>get方法主要是区分是链表还是树，其中实现是通过设置TreeBin的hash为-2,以此来区分不同的实现，然后根据不同的数据结构进行查询。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="keyword">int</span> n, eh; K ek;</div><div class="line">    <span class="keyword">int</span> h = spread(key.hashCode());</div><div class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</div><div class="line">        (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</div><div class="line">            <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))</div><div class="line">                <span class="keyword">return</span> e.val;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</div><div class="line">            <span class="keyword">return</span> (p = e.find(h, key)) != <span class="keyword">null</span> ? p.val : <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (e.hash == h &amp;&amp;</div><div class="line">                ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek))))</div><div class="line">                <span class="keyword">return</span> e.val;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="size方法要点"><a href="#size方法要点" class="headerlink" title="size方法要点"></a>size方法要点</h3><p>为了统计ConcurrentHashMap的数量，jdk设计了那个变量，一个是baseCount整型,一个是CounterCell数组，其值都是volatile变量，获取size的过程就是要统计baseCount和CounterCell数组中所有值的和。<br>至于为什么要用两个数据结构，是考虑到多线程情况下，如果有多个线程在进行put操作，那么HashMap的size都要加一，首先是尝试CAS增加baseCount，如果加入成功，则成功，如果失败，再尝试CAS修改CounterCell数组，如果成功，也算成功。如果还是失败，则轮训以上两个步骤，结束。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>ConcurrentHashMap在jdk 1.7和1.8之间的差异主要体现在一下几个方面</p><ol><li>基本的数据结构转换：1.7中使用Segment+HashEntry的数据结构，而1.8中使用Node数组存储，Node分为链表Node和红黑树TreeNode</li><li>1.7中以Segment为单位实现锁分离，1.8中大量使用CAS+状态位来控制同步，单位是Node，锁的粒度更小</li><li>1.7中的扩容机制是以Segment中加锁进行的，而1.8中可以有多个线程参与扩容的过程，速度更快。</li></ol><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://www.ctolib.com/topics-2226.html#articleHeader17" target="_blank" rel="external">ConcurrentHashMap总结</a><br><a href="http://cmsblogs.com/?p=2283" target="_blank" rel="external">J.U.C之Java并发容器：ConcurrentHashMap</a><br>Java并发编程艺术</p><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>本文首发表于<a href="https://buwenqi.github.io" target="_blank" rel="external">我的博客</a>,欢迎关注！转载须注明文章出处，作者保留文章所有权。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;线程不安全的HashMap&quot;&gt;&lt;a href=&quot;#线程不安全的HashMap&quot; class=&quot;headerlink&quot; title=&quot;线程不安全的HashMap&quot;&gt;&lt;/a&gt;线程不安全的HashMap&lt;/h2&gt;&lt;p&gt;多线程情况下，HashMap由于在扩容的时候会导致链变成环，在下一次查询的时候会使得出现死循环的出现。变成环的主要原因在于HashMap扩容的逻辑是不具有原子性的，扩容的基本逻辑包括下面三条：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;当前节点为e，获取当前节点的下一个节点next&lt;/li&gt;
&lt;li&gt;将e按照hash移到到扩容后的hash表中，置e.next等于newtable[i],头插法&lt;/li&gt;
&lt;li&gt;将e置为next进入下一次循环&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="Java并发系列" scheme="http://yoursite.com/tags/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Java并发系列笔记之线程池</title>
    <link href="http://yoursite.com/2018/05/06/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%E4%B9%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>http://yoursite.com/2018/05/06/Java并发系列笔记之线程池/</id>
    <published>2018-05-06T01:39:00.000Z</published>
    <updated>2018-05-09T08:03:08.694Z</updated>
    
    <content type="html"><![CDATA[<p>线程池是资源复用的典范之作，其基本思想是维护一个含有一定数量的在运行的线程集合，在需要运行线程任务的时候直接从这个集合中取出一个线程去运行任务，而不是重新创建一个。<br><a id="more"></a></p><p>如果我们自己去实现一个线程池，那么基本的想法是维护一个线程的集合，这些线程都从一个队列中去取任务，如果队列为空，则阻塞对应的线程，等待队列不空的消息通知。当线程完成了任务，应该将线程返回给线程队列，而不是关闭线程。基本思想是这样，那么Java中具体是如何实现线程池的呢，我们来看看。</p><h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><p>一般情况下，我们使用线程池会使用Executors的静态方法获取线程池，如</p><ul><li>public static ExecutorService newFixedThreadPool(int nThreads)</li><li>public static ExecutorService newSingleThreadExecutor()</li><li>public static ExecutorService newCachedThreadPool()</li><li>public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize)</li></ul><p>除了最后一个方法外，其它三个方法都是返回一个ThreadPoolExecutor实例，它是ExecutorService接口的一个实现类。瞄一眼ThreadPoolExecutor的构造方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></div><div class="line">                           <span class="keyword">int</span> maximumPoolSize,</div><div class="line">                           <span class="keyword">long</span> keepAliveTime,</div><div class="line">                           TimeUnit unit,</div><div class="line">                           BlockingQueue&lt;Runnable&gt; workQueue,</div><div class="line">                           ThreadFactory threadFactory,</div><div class="line">                           RejectedExecutionHandler handler)</div></pre></td></tr></table></figure></p><p>它的构造方法有多个重载，其中最终都是使用了上面这个构造方法，它包括7个参数，corePoolSize,核心线程数量；maximumPoolSize，最大线程数量；keepAliveTime,超过核心线程数量线程的在空闲后的存活时间；unit，存活时间的时间单位；workQueue，超过核心线程后任务存放的阻塞队列；threadFactory,常用定义线程名字的线程工厂，可以使用默认工厂；最后一个handler，是阻塞队列已满，并且线程数达到maximumPoolSize的时候的处理策略，其中包括了抛出异常（AbortPolicy）,谁请求谁调用（CallerRunsPolicy）,丢弃线程池中的一个任务来执行现在的任务（DiscardOldesPolicy）,直接丢弃掉（DiscardPolicy）默认使用抛异常策略。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</div><div class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</div><div class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>可以看到newFixedThreadPool使用默认工厂，默认拒绝策略，链表阻塞队列，最大线程数和核心线程数相同，并且如果超过核心线程数的线程控制，立即失效。这种比较适合任务数固定的任务。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</div><div class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</div><div class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</div><div class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>newSingleThreadExecutor的核心线程数和最大线程数都是1，并且使用LinkedBlockingQueue作为缓冲队列。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</div><div class="line">     <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</div><div class="line">                                   <span class="number">60L</span>, TimeUnit.SECONDS,</div><div class="line">                                   <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p><p>newCachedThreadPool在没有任务的时候并不创建线程，只有在任务出现的时候才使用SynchronousQueue队列传递任务给线程，但SynchronousQueue每次只能传递一个任务，新的任务首先会通过offer（非阻塞）方法尝试传递任务给线程，如果此时没有空闲的线程，会新生成线程来完成任务，而且线程的空闲时间是60s，所以比较适合任务多而且短的任务集（短的原因是总可以有空闲线程去SynchronousQueue中取任务）。关于SynchronousQueue，可以参考这几篇文章《<a href="https://segmentfault.com/a/1190000011207824" target="_blank" rel="external">SynchronousQueue使用实例</a>》,《<a href="http://cmsblogs.com/?p=2418" target="_blank" rel="external">J.U.C之阻塞队列：SynchronousQueue</a>》。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>ScheduledThreadPoolExecutor可以使用schedule方法在给定时间延迟时进行调用。</p><h2 id="ThreadPoolExecutor是如何管理线程池的？"><a href="#ThreadPoolExecutor是如何管理线程池的？" class="headerlink" title="ThreadPoolExecutor是如何管理线程池的？"></a>ThreadPoolExecutor是如何管理线程池的？</h2><p>从上面我们看到使用ThreadPoolExecutor可以获取线程池，并且可以调用execute(Runnable)和submit(Runnable)提交任务。那么在执行execute方法的时候，ThreadPoolExecutor是如何管理线程池来完成当前的任务的。我们可以从execute的源码中一窥这个处理策略<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">    <span class="keyword">int</span> c = ctl.get();</div><div class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;<span class="comment">//第一步</span></div><div class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        c = ctl.get();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;<span class="comment">//第二步</span></div><div class="line">        <span class="keyword">int</span> recheck = ctl.get();</div><div class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</div><div class="line">            reject(command);</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</div><div class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))<span class="comment">//第三步</span></div><div class="line">        reject(command);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>其基本策略有三大步，第一步，在当前的线程池中线程数量小于核心线程数量，直接调用addWork(Runnable,boolean)添加线程，并且执行任务任务，任务完成后这个线程会驻留在池中等待执行任务。如果线程数已经超过的核心线程数，第二步，则将任务使用阻塞队列的offer非阻塞方式放入队列中。如果阻塞队列也满了，则尝试addWork(Runnable,boolean)，如果线程数量超过了最大线程数量，则添加失败，调用拒绝策略。<br>addWork(Runnable)方法基本思想是首先将Runable包装成Worker，并执行Worker。Worker的数据结构使得在执行完该方法后，会尝试从阻塞队列中获取任务继续执行。<br>另外值得注意的是JDK中的线程池标注的5种状态，如下图所示<br><img src="https://i.imgur.com/uWanjuu.png" alt=""><br>只有RUNNING状态的线程池可以接收任务，处于SHUTDOWN状态的线程池不可以接受新任务，但是可以继续对已添加的任务进行处理。处于STOP状态的线程池不接收新任务，不处理已添加的任务，并且会中断正在处理的任务。TIDYING状态的线程池在执行terminated函数，而TERMINATED状态说明已经执行完terminated函数，彻底终止。其中RUNNING可以转换成SHUTDOWN(shutdown()函数)或STOP状态(shutDownNow()函数)，有STOP或SHUTDOWN状态可以转换成TIDYING，而TIDYING可以转换成TERMINATED。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="http://cmsblogs.com/?p=2448" target="_blank" rel="external">J.U.C之线程池：ThreadPoolExecutor</a><br><a href="https://juejin.im/entry/59b232ee6fb9a0248d25139a" target="_blank" rel="external">深度解读 java 线程池设计思想及源码实现</a></p><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>本文首发表于<a href="https://buwenqi.github.io" target="_blank" rel="external">我的博客</a>,欢迎关注！转载须注明文章出处，作者保留文章所有权。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;线程池是资源复用的典范之作，其基本思想是维护一个含有一定数量的在运行的线程集合，在需要运行线程任务的时候直接从这个集合中取出一个线程去运行任务，而不是重新创建一个。&lt;br&gt;
    
    </summary>
    
    
      <category term="Java并发系列" scheme="http://yoursite.com/tags/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Java并发系列笔记之Java中的锁</title>
    <link href="http://yoursite.com/2018/05/02/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%E4%B9%8BJava%E4%B8%AD%E7%9A%84%E9%94%81/"/>
    <id>http://yoursite.com/2018/05/02/Java并发系列笔记之Java中的锁/</id>
    <published>2018-05-02T01:39:00.000Z</published>
    <updated>2018-05-11T01:46:13.362Z</updated>
    
    <content type="html"><![CDATA[<p>锁是多线程下进行同步互斥的重要实现依托，Java语言中除了提供了使用synchronized关键字提供的隐式锁，也提供了以Lock接口定义的显示锁。一般Lock的子类实现依赖于一个抽象队列同步器（AbstractQueuedSynchronizer, AQS）的子类实现。AQS的目的是提供对同步状态的获取和释放的基础同步功能给依赖者使用，而屏蔽了同步状态获取和释放的具体实现。AQS是一个抽象类，它使用模板模式定义获取和释放同步状态的模板方法，而将模板方法所依赖的获取同步，阻塞管理等其他方法交给需要不同并发策略的子类去实现。本文从AQS的具体实现讲起，接着分析不同锁机制的实现原理。<br><a id="more"></a></p><h2 id="AbstractQueuedSynchronizer"><a href="#AbstractQueuedSynchronizer" class="headerlink" title="AbstractQueuedSynchronizer"></a>AbstractQueuedSynchronizer</h2><h3 id="同步状态status的获取和更新"><a href="#同步状态status的获取和更新" class="headerlink" title="同步状态status的获取和更新"></a>同步状态status的获取和更新</h3><p>开头说到“AQS的目的是提供对同步状态的获取和释放的基础同步功能给依赖者使用”，AQS用一个volatile的整型变量status表示同步状态，当status&gt;0是表示被占用的数量，status=0表示未被占用。并且提供了getState(),setState(int)以及compareAndSetState(int expect,int update),最后一个方法用CAS的方法来更新status的值，如果更新成功，则返回true,失败则返回false。<br>CAS是一种乐观锁技术，其具体实现有三个参数value,expect,update,value是内存地址中当前的值，expect是value预期的值，如果value和expect相同，则将value地址的值改为update，更新成功；否则，什么也不做，更新失败。操作系统保证读-对比-更新的原子性，这个逻辑是在native代码中实现的。具体实现如下图所示，CAS是一种乐观锁技术，所以需要使用轮询来查看是否更新成功，相比重量级的加锁，在锁竞争不是特别激烈的情况下，可以获取很好的性能提升。值得一提的是，CAS在1.8 JDK的锁优化中被大量使用。<br><img src="https://i.imgur.com/pNi7ZBp.png" alt=""></p><h3 id="可重写尝试获取和释放同步状态的方法"><a href="#可重写尝试获取和释放同步状态的方法" class="headerlink" title="可重写尝试获取和释放同步状态的方法"></a>可重写尝试获取和释放同步状态的方法</h3><p>可以重写的方法是实现自定义同步策略的关键，主要分为两大类独占式和共享式，动作上分为尝试获取同步状态和尝试释放共享状态。具体包括如下方法:</p><ul><li>protected boolean tryAcquire(int arg)//独占式的尝试获取arg个同步状态</li><li>protected boolean tryRelease(int arg)//独占式的尝试释放arg个同步状态</li><li>protected int tryAcquireShared(int arg)//共享式的获取arg个同步状态，如果返回大于等于0，则成功，否则失败</li><li>protected boolean tryReleaseShared(int arg)//共享式的尝试释放arg个同步状态</li><li>protected boolean isHeldExclusively()//独占状态下用于判定是否被占用状态</li></ul><p>所谓独占式和共享式是指是不是只允许单独的一个线程获取共享状态而阻塞其他的线程的获取，如果是的，则是独占式，否则则是共享式。我们可以根据不同的同步需求，继承AQS，实现不同的获取同步状态的策略。</p><h3 id="同步控制的模板方法"><a href="#同步控制的模板方法" class="headerlink" title="同步控制的模板方法"></a>同步控制的模板方法</h3><p>一般获取同步状态有两种结果：成功获取同步状态，这种情况下线程可以愉快的继续执行；获取同步状态失败，这种情况下需要AQS来维护获取同步状态失败的线程状态。从方法上来看，AQS支持多个种模板方法的实现，主要分为两大类，独占式的获取和释放同步状态和共享式的获取和释放同步状态。其中获取同步状态有非响应中断式的(默认)和响应中断式的，等待固定时间的获取。<br>独占式:</p><ol><li>public final void acquire(int arg)</li><li>public final void acquireInterruptibly(int arg)</li><li>public final boolean tryAcquireNanos(int arg, long nanosTimeout)</li><li>public final boolean release(int arg)</li></ol><p>共享式：</p><ol><li>public final void acquireShared(int arg)</li><li>public final void acquireSharedInterruptibly(int arg)</li><li>public final boolean tryAcquireSharedNanos(int arg, long nanosTimeout)</li><li>public final boolean releaseShared(int arg) </li></ol><p>那么AQS是如何处理获取同步状态的呢？以独占式的acquire(int)实现为例<br><img src="https://i.imgur.com/KlMgwG8.png" alt=""><br>模板方法首先尝试获取arg个同步状态（tryAcquire），如果成功了，直接方法返回，代表成功获取同步状态；如果失败了，AQS使用一个称为同步队列的双向队列来维护获取失败的线程信息，队列中的存储单元是封装了线程，线程状态和前驱后继的节点信息，AQS持有双向队列的头部（head）和尾部(tail)节点引用。<br>addWaiter就是将当前未获取同步状态的线程封装成Node添加在双向队列的尾部，当然插入的过程使用了CAS并且再失败的时候进行自旋。<br>接着acquireQueue尝试自旋获取同步状态，当然只有前驱节点为头结点的Node等待线程才可以获取同步状态，如果不是头结点或获取同步状态失败，则判断是否应该阻塞当前线程，判断的依据是当前Node前驱节点的waitStaus。如果是应该阻塞，则使用LockSupport的park(Thread)方法阻塞当前线程，否则，继续自旋。如果前驱是头节点并且尝试获取同步状态成功，则设置当前节点为头结点(也就是说头结点是获取同步状态的)，并且返回。<br>总结起来，独占式获取同步状态的状态图如下：<br><img src="https://i.imgur.com/G5In2rj.png" alt=""></p><h4 id="独占式释放同步状态基本思路"><a href="#独占式释放同步状态基本思路" class="headerlink" title="独占式释放同步状态基本思路"></a>独占式释放同步状态基本思路</h4><p>基本的流程是尝试使用tryRelease(int)释放同步状态，如果释放成功，则当前线程会唤醒同步队列中后继节点的线程，并且返回true,否则返回false。release做的工作相对较少。</p><h4 id="共享式获取同步状态基本思路"><a href="#共享式获取同步状态基本思路" class="headerlink" title="共享式获取同步状态基本思路"></a>共享式获取同步状态基本思路</h4><p>acquireShared(int)首先使用tryAcquireShared尝试获取同步状态，如果返回小于0则获取失败，将失败的线程放入同步队列中，并且自旋式尝试获取同步状态，只有前驱节点是头结点才可以尝试获取同步状态，如果成功了则设置当前节点为头结点，如果失败了则判断是否应该阻塞当前线程。整个过程和独占式acquire类似，不同的是tryAcquiredShared方法在获取锁的时候不用判断当前线程是不是独占式线程，任何线程在开始的时候都可以尝试获取同步状态。而tryAquired的实现应该排斥非独占线程获取锁。</p><h4 id="共享式释放同步状态基本思路"><a href="#共享式释放同步状态基本思路" class="headerlink" title="共享式释放同步状态基本思路"></a>共享式释放同步状态基本思路</h4><p>releaseShared(int)首先尝试释放同步状态，并且使用doReleaseShared()循环唤醒队列中多个等待的线程。</p><h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><p>看过了队列同步器的实现，我们来看看其具体的锁是如何运用AQS实现同步操作的。ReetrantLock是可重入锁，可重入的意思是同一个线程可以多次获取锁，并且可重入锁是独占式的，也就是同一时刻只有一个线程可以获得锁。并且可重入锁支持公平和非公平两种模式，所谓公平，指的是获取锁的请求是否遵循先到先得的FIFO规则，如果是FIFO则是公平的，否则则是非公平的。ReentrantLock持有一个继承了AQS的内部类Sync，并且定义了两个子类NonfairSync和FairSync,他们重写了AQS定义的尝试获取独占锁的tryAquire(int)：boolean方法。我们首先来看非公平的tryAquire的实现。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</div><div class="line">    <span class="keyword">int</span> c = getState();</div><div class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</div><div class="line">            setExclusiveOwnerThread(current);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</div><div class="line">        <span class="keyword">int</span> nextc = c + acquires;</div><div class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</div><div class="line">        setState(nextc);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>其基本流程是：首先判断当前状态是否为0，如果是0使用CAS将设置成acquires，并且设置当前线程为独占线程，否则，如果线程为独占线程，则将状态设置为当前同步状态+acquires,因为独占状态下，不会有其他线程修改同步状态，可以不用CAS进行设置。如果设置成功返回true，否则返回false。<br>对别公平的tryAcquire实现，其代码如下,唯一的区别是在同步状态为0的时候，程序会检查当前是不是头结点持有的线程，如果是的话才可以尝试CAS设置，也就是对应的hasQueuedPredecessors方法。所以，在一个新的线程尝试获取公平锁的时候，如果它不是FIFO队列的头结点，则获取会失败，从而保证了公平性。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</div><div class="line">            <span class="keyword">final</span> Thread current = Thread.currentThread();</div><div class="line">            <span class="keyword">int</span> c = getState();</div><div class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</div><div class="line">                <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</div><div class="line">                    compareAndSetState(<span class="number">0</span>, acquires)) &#123;</div><div class="line">                    setExclusiveOwnerThread(current);</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</div><div class="line">                <span class="keyword">int</span> nextc = c + acquires;</div><div class="line">                <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</div><div class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</div><div class="line">                setState(nextc);</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p><p>获取完同步状态后，会进行同步状态的释放，也就是重写tryRelease(int)方法，公平锁和非公平锁的共用的Sync的tryRelease方法,只有独占线程才可以释放同步状态，如果同步状态变成了0，才最终释放成功。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</div><div class="line">     <span class="keyword">int</span> c = getState() - releases;</div><div class="line">     <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</div><div class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</div><div class="line">     <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</div><div class="line">     <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</div><div class="line">         free = <span class="keyword">true</span>;</div><div class="line">         setExclusiveOwnerThread(<span class="keyword">null</span>);</div><div class="line">     &#125;</div><div class="line">     setState(c);</div><div class="line">     <span class="keyword">return</span> free;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p><h3 id="回顾整个流程"><a href="#回顾整个流程" class="headerlink" title="回顾整个流程"></a>回顾整个流程</h3><p>回顾整个流程，自顶向下的看以非公平的ReentrantLock实现过程，在用户需要使用ReentrantLock调用lock()方法，lock()方法会使用Sync的lock()方法使用CAS第一次尝试获取同步状态，如果获取成功，则直接设置当前线程为独占线程，如果失败，则会调用acquire(1)方法尝试一个同步状态，acquire则会调用tryAcquire(1)尝试获取同步状态，这个tryAcquire()是我们在实现AQS的子列NofaireSync中实现的，如果获取成功了，则正常返回，如果失败了，则会调用尝试将当前线程信息打包成Node节点加入到同步队列中，并且自旋尝试获取同步状态，当然只能前驱是头结点的线程才会多次自旋尝试获取同步状态，其余的则会阻塞等待。当同步状态使用完毕后，调用unlock()释放同步状态时，unlock方法会调用release()模板方法，而release模板方法会使用tryRelease()自定义策略释放同步状态，如果成功的话，则使用LockSupport.unpark(Thread)唤醒当前节点的后继节点。<br>回顾了整个流程我们就清晰了AQS在ReentrantLock实现过程中的作用，其中最重要的就是在获取同步状态失败后对同步队列的管理，而AQS提供了模板方法使得我们可以实现抽象方法所依赖的尝试获取同步状态的方法来控制获取同步状态的策略。</p><h2 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h2><p>可重入读写锁锁包含了两个锁读写锁，这两个锁的同步状态用一个int值的高16位和低16位表示，高16位表示读锁，低16位表示写锁。其中写锁是独占锁，也就是一旦一个线程获取了写锁，其他线程对读锁和写锁的请求都会被阻塞。读锁是共享锁，也就是多个线程可以同时获取读锁，但是在有线程获取读锁的过程中，写锁会被阻塞。我们可以通过ReentrantReadWriteLock中Sync的tryAcquire(int)和tryAcquireShared(int)看到这种读写策略。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</div><div class="line">    <span class="comment">/*</span></div><div class="line">     * Walkthrough:</div><div class="line">     * 1. If read count nonzero or write count nonzero</div><div class="line">     *    and owner is a different thread, fail.</div><div class="line">     * 2. If count would saturate, fail. (This can only</div><div class="line">     *    happen if count is already nonzero.)</div><div class="line">     * 3. Otherwise, this thread is eligible for lock if</div><div class="line">     *    it is either a reentrant acquire or</div><div class="line">     *    queue policy allows it. If so, update state</div><div class="line">     *    and set owner.</div><div class="line">     */</div><div class="line">    Thread current = Thread.currentThread();</div><div class="line">    <span class="keyword">int</span> c = getState();</div><div class="line">    <span class="keyword">int</span> w = exclusiveCount(c);</div><div class="line">    <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">// (Note: if c != 0 and w == 0 then shared count != 0)</span></div><div class="line">        <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread())</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</div><div class="line">        <span class="comment">// Reentrant acquire</span></div><div class="line">        setState(c + acquires);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (writerShouldBlock() ||</div><div class="line">        !compareAndSetState(c, c + acquires))</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    setExclusiveOwnerThread(current);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>可以看到上面的注释，在写锁的获取中，如果读锁不为0或者写锁不是当前线程，则获取失败。否则说明是已经获取写锁的独占线程，直接设置同步状态即可。否则的话，如果公平锁控制方法writerShouldBlock返回false并且尝试使用CAS设置，如果成功了，则获取写锁才成功。<br>读锁的过程比较简单，基本思路是如果写锁同步状态不为0并且当前线程不为写锁的持有者，则获取失败，使用与逻辑的原因是如果当前线程获取了写锁，还可以竞争读锁。然后最后使用CAS设置加后的读锁。</p><h2 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h2><p>每个Lock实现类还实现了newCondition方法，该方法返回一个Condition对象，AQS的内部类ConditionObject实现了Condition接口，一般newCondition方法会返回一个ConditionObject实例。<br>Condition使用await/signal方法实现了比Object类提供的wait/notify更细粒度的线程间通信方式，一个锁可以获取多个Condition实例。那么AQS的ConditionObject是如何实现await/signal来实现线程间的通信的呢。<br>具体来说，每个ConditionObject对象持有一个像同步队列一样的双向队列，其中的每个节点也是Node,当一个获取了锁的线程调用await的时候，会释放同步状态并且将其从同步队列的头部移到当前Condition的等待队列，并且调用unpark方法阻塞当前线程，等待唤醒。<br><img src="https://i.imgur.com/Yxp3OBt.png" alt=""><br>而signal方法则是获取当前ConditionObject等待队列的头部节点，将其移动到同步队列的尾部并且使用LockSupport.unpark唤醒它。<br><img src="https://i.imgur.com/r0Qf58S.png" alt=""></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="http://shift-alt-ctrl.iteye.com/blog/1839142" target="_blank" rel="external">AQS(AbstractQueuedSynchronizer)深入剖析</a></li><li><a href="https://segmentfault.com/a/1190000008471362#articleHeader0" target="_blank" rel="external">浅谈Java并发编程系列（九）—— AQS结构及原理分析</a></li><li><a href="http://cmsblogs.com/?p=2235" target="_blank" rel="external">深入分析CAS</a></li><li>Java并发编程艺术</li></ul><p>本文首发表于<a href="https://buwenqi.github.io" target="_blank" rel="external">我的博客</a>,欢迎关注！转载须注明文章出处，作者保留文章所有权。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;锁是多线程下进行同步互斥的重要实现依托，Java语言中除了提供了使用synchronized关键字提供的隐式锁，也提供了以Lock接口定义的显示锁。一般Lock的子类实现依赖于一个抽象队列同步器（AbstractQueuedSynchronizer, AQS）的子类实现。AQS的目的是提供对同步状态的获取和释放的基础同步功能给依赖者使用，而屏蔽了同步状态获取和释放的具体实现。AQS是一个抽象类，它使用模板模式定义获取和释放同步状态的模板方法，而将模板方法所依赖的获取同步，阻塞管理等其他方法交给需要不同并发策略的子类去实现。本文从AQS的具体实现讲起，接着分析不同锁机制的实现原理。&lt;br&gt;
    
    </summary>
    
    
      <category term="Java并发系列" scheme="http://yoursite.com/tags/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Java中的异步执行Future小结</title>
    <link href="http://yoursite.com/2018/03/27/Java%E4%B8%AD%E7%9A%84%E5%BC%82%E6%AD%A5%E6%89%A7%E8%A1%8CFuture%E5%B0%8F%E7%BB%93/"/>
    <id>http://yoursite.com/2018/03/27/Java中的异步执行Future小结/</id>
    <published>2018-03-27T01:39:00.000Z</published>
    <updated>2018-03-31T01:55:03.116Z</updated>
    
    <content type="html"><![CDATA[<p>最近碰到的异步处理的操作比较多，异步就是不等想要的结果返回执行接下来的其他操作，等异步结果返回后直接调用已经注册好的处理方法完成后续操作。异步的思想是非常棒的，相比轮询的方式而言，异步的实现方式无疑是高效并且优雅的。本文介绍了包括Future，AIO和有点类似于单机版的Map-Reduce的fork/join框架。<br><a id="more"></a></p><h2 id="Guava-ListenableFuture"><a href="#Guava-ListenableFuture" class="headerlink" title="Guava ListenableFuture"></a>Guava ListenableFuture</h2><p>使用JDK提供的线程池ExcuteService的execute(Runable runable)方法来执行不需要返回结果的线程任务，而使用submit(Callable<t> callable)方法需要线程任务返回T类型的执行结果，方法返回Future<t>对象，使用Future的get方法可以获取执行结果，而在执行get方法在线程返回结果之前是阻塞的，jdk这对于想要异步的处理结果没有提供相应的接口，guava的ListenableFuture接口就是为实现异步的获取Future中的结果而出现的。<br>顾名思义，ListenableFuture是可监听的Future,可以在结果返回的时候以方法回调的方式实现异步的后续操作。那么如何获取ListenableFuture呢，方法有两种：</t></t></p><ol><li>将jdk提供的Futhure转换成ListenableFuture</li><li>将ExcutorService线程池转换成ListeningExcutorService,继而获取ListenableFuture</li></ol><p>第一种方式我们使用如下适配器获得Future对应的ListenableFuture<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ListenableFuture&lt;String&gt; listenableFuture=JdkFutureAdapters.listenInPoolThread(future);</div></pre></td></tr></table></figure></p><p>第二种方式我们使用一个线程池的修饰类获得<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ListeningExecutorService listeningThreadPool=MoreExecutors.listeningDecorator(threadPool);</div><div class="line">ListenableFuture&lt;String&gt; listenableFuture=listeningThreadPool.submit(<span class="keyword">new</span> Callable&lt;String&gt;() &#123;....&#125;</div></pre></td></tr></table></figure></p><p>在获取了ListenableFuture之后，我们同样有两种方式异步获取线程执行结果</p><ol><li>添加FutureCallback执行回调方法</li><li>为ListenableFuture添加监听线程</li></ol><p>第一种方法使用Futures的addCallback方法实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Futures.addCallback(listenableFuture,<span class="keyword">new</span> FutureCallback&lt;String&gt;()&#123;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(String result)</span> </span>&#123;</div><div class="line">                System.out.println(result);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Throwable t)</span> </span>&#123;</div><div class="line">                t.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure></p><p>第二种方法不太推荐，使用listenableFuture.addListener的方法实现。</p><h3 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h3><p>我们看到guava的实现方式非常优雅，那么它是怎么实现这种异步回调的呢，以JdkFutureAdapters.listenInPoolThread为例，其实他是返回了一个ListenableFutureAdapter的内部类，它实现了ListenableFuture并且继承了ForwardingFuture类，然后调用callback的时候会新建一个Runable线程任务，其主要逻辑是使用Future的get方法阻塞获取执行结果，在结果完成的时候回到callback类的onSuccess方法，如果出现异常则调用onFailure方法。<br>整个方法的设计使用了适配器模式，ListenableFuture是最终用户需要的接口，ListenableFutureAdapter是适配器，ForwordingFuture实现了Future接口，是被适配者。</p><h3 id="关于FutureTask"><a href="#关于FutureTask" class="headerlink" title="关于FutureTask"></a>关于FutureTask</h3><p>FutureTask是Future的一个实现类，它同时实现了Runable接口，直接使用线程池运行FutureTask,并且获取阻塞获取结果，其在异步方面并没有做出改变。</p><h3 id="本节代码"><a href="#本节代码" class="headerlink" title="本节代码"></a>本节代码</h3><p>所有测试代码获取可以点击<a href="https://github.com/buwenqi/JavaBasis/tree/master/src/main/java/guavafuture" target="_blank" rel="external">这里</a><br>参考文献：<a href="https://chen310.gitbooks.io/guava/content/bing_fa.html" target="_blank" rel="external">guava并发</a>，<a href="http://www.importnew.com/25286.html" target="_blank" rel="external">深入学习 FutureTask</a></p><h2 id="Java-AIO中的Future和CompleteHandler"><a href="#Java-AIO中的Future和CompleteHandler" class="headerlink" title="Java AIO中的Future和CompleteHandler"></a>Java AIO中的Future和CompleteHandler</h2><p>Socket通信是Java网络通信的一种方式，在基础的阻塞BIO后出现了NIO，NIO采用了多路复用思想，使得一个线程可以监听多个socket文件描述符，使得在在一次轮训的过程中可以查看多个阻塞IO的状态，相比BIO每次只能监听一个IO状态，如果这个IO长期处于阻塞状态，那么其他IO操作如果准备好也无法执行。<br>BIO的另一个问题是在于对于每个准备好的IO操作必须分配一个线程进行实际的阻塞IO操作，这使得系统的线程数和已准备好的IO操作成线性关系。NIO的优势在于它可以对多个已准备好的IO阻塞操作做打包操作，做线程数的缩减。<br>NIO对数据的操作是面向缓冲区的，而BIO是面向数据流的，NIO中面向缓冲区的IO操作是讲所有的数据一次读入到缓冲区内，进而做操作，这相比BIO的面向数据流的IO每次只能读入一个或多个字节的方式，这种方式更加快捷。<br>NIO本质其实还是采用轮询的方式去获取已准备好的IO操作，实际的读写IO操作仍然是阻塞的，Java AIO是对NIO的又一次改进，其真正实现了异步的IO操作，包括获取准备好的操作，读写操作都是异步的，其执行都会直接返回一个Future对象，我们可以使用其get方法阻塞接下来的执行。<br>Java AIO主要用到的类有：</p><ol><li>AsynchronousSocketChannel</li><li>AsynchronousServerSocketChannel</li></ol><p>AsynchronousSocketChannel的connet方法为其准备io操作，write和read方法为其实际的IO操作，同样的AsynchronousServerSocketChannel的accept方法为其准备io操作，读写操作是和AsynchronousSocketChannel一样的。<br>以上方法都是异步的，也就是说方法会立即返回，获取异步执行结果的方法有两种：</p><ol><li>获取Future结果，使用Future的get方法获取执行结果</li><li>使用CompletionHandler的回调方法在结果返回的时候获取结果</li></ol><p>以AsynchronousServerSocketChannel为例，其connet方法有两个重载方式：</p><ol><li>accept()无参方式返回一个Future<asynchronoussocketchannel>,可以使用get方法获取连接的client。</asynchronoussocketchannel></li><li>accept(A attach,CompletionHandler<asynchronoussocketchannel,a>)，无返回值，在接收到client连接的时候执行CompletionHandler中的completed回调方法。</asynchronoussocketchannel,a></li></ol><p>具体的，我们使用一个Echo的server/client的程序来测试Java AIO，其Server端实现如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AioEchoServer</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> PORT = <span class="number">9955</span>;</div><div class="line">    <span class="keyword">private</span> String IP = <span class="string">"127.0.0.1"</span>;</div><div class="line">    <span class="keyword">private</span> AsynchronousServerSocketChannel server;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AioEchoServer</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            server = AsynchronousServerSocketChannel.open().bind(<span class="keyword">new</span> InetSocketAddress(IP, PORT));</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startServer</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">//attachment参数可以被CompletionHandler接收</span></div><div class="line"></div><div class="line">        server.accept(<span class="string">"attachment"</span>, <span class="keyword">new</span> CompletionHandler&lt;AsynchronousSocketChannel, String&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(AsynchronousSocketChannel client, String attachment)</span> </span>&#123;</div><div class="line">                <span class="comment">//获取了对应的客户端socket</span></div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    System.out.println(<span class="string">"attachment: "</span> + attachment);</div><div class="line">                    ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</div><div class="line">                    <span class="comment">//这里是非阻塞读取，需要使用get等待客户端返回结果</span></div><div class="line">                    <span class="keyword">int</span> readResult = client.read(byteBuffer).get();</div><div class="line">                    System.out.println(<span class="string">"读入数据量："</span> + readResult);</div><div class="line">                    byteBuffer.flip();</div><div class="line">                    System.out.println(<span class="string">"Get from client:"</span> + (<span class="keyword">new</span> String(byteBuffer.array())));</div><div class="line">                    <span class="keyword">int</span> writeResult = client.write(byteBuffer).get();</div><div class="line">                    <span class="keyword">if</span> (writeResult &gt; <span class="number">0</span>) &#123;</div><div class="line">                        System.out.println(client.getRemoteAddress() + <span class="string">": "</span> + <span class="string">"response success! write length: "</span> + writeResult);</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        System.out.println(<span class="string">"write length &lt;0"</span>);</div><div class="line">                    &#125;</div><div class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                    server.accept(<span class="keyword">null</span>,<span class="keyword">this</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, String attachment)</span> </span>&#123;</div><div class="line">                exc.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        AioEchoServer aioEchoServer = <span class="keyword">new</span> AioEchoServer();</div><div class="line">        aioEchoServer.startServer();</div><div class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</div><div class="line">        scanner.nextLine();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>客户端的实现方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">public class AioClient &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        String IP = &quot;127.0.0.1&quot;;</div><div class="line">        int PORT = 9955;</div><div class="line">        final AsynchronousSocketChannel client;</div><div class="line">        try &#123;</div><div class="line">            client = AsynchronousSocketChannel.open();</div><div class="line">            SocketAddress serverSocketAddress = new InetSocketAddress(IP, PORT);</div><div class="line">            client.connect(serverSocketAddress, &quot;clientAttachment&quot;, new CompletionHandler&lt;Void, String&gt;() &#123;</div><div class="line">                @Override</div><div class="line">                public void completed(Void result, String attachment) &#123;</div><div class="line">                    System.out.println(attachment);</div><div class="line">                    try &#123;</div><div class="line">                        ByteBuffer byteBuffer = ByteBuffer.wrap(&quot;hello&quot;.getBytes());</div><div class="line">                        //wrap后不用byteBuffer.flip()，此时position=0，limit是之前position的位置</div><div class="line">                        //read后的postion是写入的界限，limit=capbility,flip做的事情:limit=poition,position=0.</div><div class="line">                        //须阻塞写入</div><div class="line">                        int writeResult = client.write(byteBuffer).get();</div><div class="line">                        System.out.println(&quot;写入Byte数：&quot; + writeResult);</div><div class="line">                        //须阻塞读取</div><div class="line">                        byteBuffer.clear();</div><div class="line">                        int readResult = client.read(byteBuffer).get();</div><div class="line">                        byteBuffer.flip();</div><div class="line">                        System.out.println(&quot;server response: &quot; + (new String(byteBuffer.array())));</div><div class="line">                    &#125; catch (Exception e) &#123;</div><div class="line">                        e.printStackTrace();</div><div class="line">                    &#125; finally &#123;</div><div class="line">                        try &#123;</div><div class="line">                            client.close();</div><div class="line">                        &#125; catch (IOException e) &#123;</div><div class="line">                            e.printStackTrace();</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                @Override</div><div class="line">                public void failed(Throwable exc, String attachment) &#123;</div><div class="line">                    exc.printStackTrace();</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">        &#125; catch (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        Scanner scanner=new Scanner(System.in);</div><div class="line">        scanner.nextLine();</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>需要注意的有两点，不论是client还是server,其write和read都是非阻塞的，模拟的情况下我们需要阻塞等待其结果返回；二是ByteBuffer.wrap方法之后不用flip操作，其返回的结果已经是flip过的，作者在这里踩了坑。</p><h2 id="单机版Map-Reduce-fork-join框架"><a href="#单机版Map-Reduce-fork-join框架" class="headerlink" title="单机版Map-Reduce fork/join框架"></a>单机版Map-Reduce fork/join框架</h2><p>fork/join框架类似于单机版的Map-Reduce，如果一个计算任务数据量比较大，就将任务分解交给不同的线程去处理，然后最后汇总结果，这种计算模型对于多核处理器来说具有极大的优势。使用fork/join框架的基本过程如下。</p><ol><li><p>实现一个类继承自RecursiveTask(或者无返回值的RecursiveAction)</p><ol><li>实现compute方法，将任务拆分成多个自实现的RecursiveTask</li><li>invokeAll(所有自实现的RecursiveTask);</li><li>使用自实现的RecursiveTask的join方法获取执行结果</li><li>汇总返回结果并返回</li></ol></li><li><p>使用ForkJoinPool的invoke方法调用上一步自定义的计算任务</p></li></ol><p>下例实现了一个计算数组中所有数和的任务<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> THRESHOLD=<span class="number">3</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] integers;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> start;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> end;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CountTask</span><span class="params">(<span class="keyword">int</span>[] integers,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.integers=integers;</div><div class="line">        <span class="keyword">this</span>.start=start;</div><div class="line">        <span class="keyword">this</span>.end=end;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> Integer <span class="title">compute</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> len=end-start+<span class="number">1</span>;</div><div class="line">        <span class="keyword">boolean</span> isOverThreshold=len&gt;THRESHOLD;</div><div class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</div><div class="line">        <span class="keyword">if</span>(!isOverThreshold)&#123;</div><div class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;=end;i++)&#123;</div><div class="line">               sum+=integers[i];</div><div class="line">           &#125;</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            <span class="keyword">int</span> mid=(start+end)/<span class="number">2</span>;</div><div class="line">            CountTask leftTask=<span class="keyword">new</span> CountTask(<span class="keyword">this</span>.integers,start,mid);</div><div class="line">            CountTask rightTask=<span class="keyword">new</span> CountTask(<span class="keyword">this</span>.integers,mid+<span class="number">1</span>,end);</div><div class="line">            invokeAll(leftTask,rightTask);</div><div class="line">            <span class="comment">//fork的作用是将当前任务放到workerThread里面去做</span></div><div class="line">            <span class="comment">//invokeAll是将其中一个放在本线程做，其他的调用fork</span></div><div class="line">            <span class="keyword">int</span> leftResult=leftTask.join();</div><div class="line">            <span class="keyword">int</span> rightResult=rightTask.join();</div><div class="line">            sum=leftResult+rightResult;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> sum;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkjoinTest</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span>[] integers=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</div><div class="line">        ForkJoinPool forkJoinPool=<span class="keyword">new</span> ForkJoinPool(<span class="number">4</span>);</div><div class="line">        ForkJoinTask&lt;Integer&gt; task=<span class="keyword">new</span> CountTask(integers,<span class="number">0</span>,<span class="number">9</span>);</div><div class="line">        <span class="keyword">int</span> sum=forkJoinPool.invoke(task);</div><div class="line">        System.out.println(sum);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>值得一提的是fork/join框架是jdk8的stream实现的计算模型，如果想要深入了解stream的实现原理，可以参考这篇文章<a href="https://www.cnblogs.com/Dorae/p/7779246.html" target="_blank" rel="external">Java8 Stream原理深度解析</a>。</p><h2 id="关于源码"><a href="#关于源码" class="headerlink" title="关于源码"></a>关于源码</h2><p>本文所有源码可以从<a href="https://github.com/buwenqi/JavaBasis/tree/master/src/main/java" target="_blank" rel="external">这里</a>获得，本文首发表于<a href="https://buwenqi.github.io" target="_blank" rel="external">我的博客</a>,欢迎关注！转载须注明文章出处，作者保留文章所有权。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近碰到的异步处理的操作比较多，异步就是不等想要的结果返回执行接下来的其他操作，等异步结果返回后直接调用已经注册好的处理方法完成后续操作。异步的思想是非常棒的，相比轮询的方式而言，异步的实现方式无疑是高效并且优雅的。本文介绍了包括Future，AIO和有点类似于单机版的Map-Reduce的fork/join框架。&lt;br&gt;
    
    </summary>
    
    
      <category term="Java进阶" scheme="http://yoursite.com/tags/Java%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title>关于常用设计模式的一些思考</title>
    <link href="http://yoursite.com/2018/03/15/%E5%85%B3%E4%BA%8E%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/"/>
    <id>http://yoursite.com/2018/03/15/关于常用设计模式的一些思考/</id>
    <published>2018-03-15T03:57:05.000Z</published>
    <updated>2018-05-07T06:23:03.992Z</updated>
    
    <content type="html"><![CDATA[<p>很早就接触了设计模式，今天在看一些文章的时候发现自己在学习理解设计模式的时候有些偏差。设计模式应该服务于特定的场景，并且是经过前人经验总结而来的代码解决思路，这种解决思路考虑的点在于如何能够让代码之间的耦合度更低并且减少冗余，使得代码耦合度更低的目的是为了程序更好的扩展，所谓的更好的扩展是指在功能的变动或者扩展的情况下尽可能触发较少的改动。所以在学习设计模式的时候，一个好的学习方式应该是模拟程序的扩展来比较在使用前人总结的设计模式和现有代码的不同之处，只有真正体会到其优点，才能尽得其精髓。</p><a id="more"></a><h2 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h2><p>创建行模式抽象了对象的实例化过程，它帮助一个系统如独立于如何创建、组合和表示那些对象。</p><h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><p><img src="https://i.imgur.com/03cbYjx.png" alt=""><br>抽象工厂模式用于创建具有不同产品族的工厂，所谓产品族是值得是多个不同对象的组合，不同对象值得是相对于实现同一接口的对象来说，所以同一产品族的对象肯定不是实现同一接口。</p><p>抽象工厂模式包括7个主要角色，A类抽象角色和A类具体角色（AbstractProductA,ProductA）,B类抽象角色和B类具体角色（AbstractProductB,ProductB）,抽象工厂（AbstractFactory）提供A类产品和B类产品的两个方法接口，具体工厂（ConcreteFactory）实现抽象工厂的两个方法接口，两个方法接口的实现依赖于A，B不同的产品（createProductA从A产品的实现类中挑选一个实现类，createProductB从B产品的实现类中挑选一个实现类）。客户短（Client）依赖于抽象工厂的具体实现类，生产一个具体工厂的产品族产品。</p><p>抽象工厂模式实现了多个产品的产品族工厂的提供，实现了多个产品的多维组合，一个典型的例子的产品族如UnixButton和WindowsButton。适用于不同产品组合的工厂提供。从扩展的角度来看，具体工厂的实现了抽象工厂，如果需要一个新的产品族，只要再实现一个产品族即可，实现了热插拔。对比工厂模式，具体工厂面临的是一个产品，而抽象工厂面临的是一系列产品。<br><img src="https://i.imgur.com/KV8IGZY.png" alt=""></p><h3 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h3><p><img src="https://i.imgur.com/Fk7UYkD.png" alt=""><br>建造者模式的作用是将一个对象的构建步骤抽象出来，使得易于重写一个对象的构建过程。</p><p>建造者模式包括4个主要角色，建造者接口（Builder），具体建造者（ConcreteBuilder），产品对象(Product)和导演类(Director)。导演类的construct方法负责调用抽象建造者的多个buildPart方法进行组装，Builder接口定义多个部分组建过程buildPart()方法和组建结果方法retrieveResult()方法供具体建造者实现，ConcreteBuilder实现部分组建方法和结果返回方法，具体的建造者完成对应的组装任务，并且使用retrieveResult获取对应的组装结果。</p><p>从目的上来看，建造者模式实现了对象的不同组装方式的最简实现方式，组建的顺序由导演类控制，而具体的组装任务分布在不同的构建者手里，导演类和抽象建造者的聚合关系使得产品构建的实际操作可以实现热插拔，使得构建的具体实现更容易扩展或替换。反观，如果使用导演类直接操作产品实现产品的组装过程，如果需要更改建造的过程，那么必须要修改导演类，这是我们不想看到的。</p><h2 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h2><p>结构型模式侧重于解决如何组装现有的类，设计他们之间的交互，以达到一定的目的，比如扩展性，封装性。</p><h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p><img src="https://i.imgur.com/MUdhZ9F.png" alt=""><br>适配器模式的目的是将一个类的方法接口转换成另一个客户端将要使用的另一个方法接口。</p><p>适配器模式含有三个主要角色，客户端需要的目标接口（Target）及其方法sampleOperation()；被适配的类Adaptee，它是实际的执行者；适配器Adapter，Adapter继承了Target接口，并且继承了Adaptee，Adapter的sampleOperation方法调用Adptee的sampleOperation方法。实际上，对Adaptee类方法的调用可以使用继承的方式，也可以使用直接依赖的方式，前者被称为类适配器，后者被称为对象适配器。</p><p>适配器模式实现了一个接口到另一个接口之间的兼容性转换。在扩展性方面并无特别的地方。</p><h3 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h3><p><img src="https://i.imgur.com/tBSFBiw.png" alt=""><br>装饰器模式又称为包装模式，其目的是在不改变原有继承关系的情况下，动态的扩展类的功能。这里所说的扩展的类的功能可以是已有方法的改变，也可以是提供更多的方法。</p><p>装饰器模式含有4个主要角色，系统已经存在的继承关系，组件接口（Component）和其实现类（ConcreteComponent）,装饰者（Decorator）实现了组件接口依赖于被装饰的具体实现类，其sampleOperateration()方法依赖于被装饰的具体组建类的sampleOperation()方法，然后具体的装饰者（ConcreateDecorator）继承自Decorator，可以实现增加其他方法或者修改对应的sampleOperation方法，从而实现了不改变原有类并且实现继承同样的动态方法扩充，并且对于客户端来说这种扩充是透明的。</p><p>从扩展的角度来看，Decorator代替的原来ConCreteComponent的位置，并且替代其完成继承的动态扩充，相比直接继承自ConcreteComponent，这种方法的依赖性更小，其装饰的对象也是可以动态插拔的，并且ConcreteComponent并需要知道装饰类的存在，免去复杂类关系的维护。</p><p>一个应用的具体例子就是BufferInputStream和FileInputStream之间的关系，InputStream是Component, FileInputStream、ByteArrayInputStream等是具体组件，FilterInputStream是装饰者，BufferInputStream等继承自FilterInputStream,是具体的装饰者。<br><img src="https://i.imgur.com/B5bPhNM.png" alt=""></p><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p><img src="https://i.imgur.com/lWm1rOr.png" alt=""><br>代理模式的目的是为一个对象提供一个代理，代理对象可以增强，修改甚至删除原有的功能。<br>因为代理模式应用十分广泛，所以代理模式已经在另一篇博客中详加叙述了，这里不再累赘。</p><h2 id="结构型模式-1"><a href="#结构型模式-1" class="headerlink" title="结构型模式"></a>结构型模式</h2><p>结构型设计模式专注于类或对象之间的职责分配，研究的是多个类或对象如何高效的合作来完成一个任务。</p><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p><img src="https://i.imgur.com/m3ocIHM.png" alt=""><br>观察者模式的目的是实现一种一对多的依赖关系，使得主题更新的时候能够将这种更新以特定的方式通知与主题绑定的观察者。</p><p>观察者模式包含4个参与者，主题接口和具体实现主题（Subject,ConcreteSubject），观察者和具体观察者（Observer,ConcreateObserver）。observer通过聚合方式注册到Subject中，由于依赖关系定义接口中，具体主题可以实现不同的通知策略，并且具体观察者和具体主题之间可以实现低耦合依赖。<br>两者之间的依赖关系可以通过attach和detach方法进行建立和解除，subject在状态改变时可以通过notifyObserver通知所有的observers,调用对应observer的update方法。<br>从扩展的角度来看，观察者模式的好处在于在新增observer的时候只需要实现observer接口，然后在想要监听的具体subject中attach就实现了添加；同样的，如果想要删除一个subject中的一个observer也仅仅需要调用attach方法，实现了热插拔。如果不采用这种设计方式，任何一方不适用接口都会导致一方的添加困难。</p><h3 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h3><p><img src="https://i.imgur.com/pCyubN5.png" alt=""><br>中介者模式的作用是使用一个中介对象封装一系列对象的交互，使得各个对象的交互不需要显示的相互依赖。简单来讲，就是让不同对象之间的交互由多对多的网状关联转换成一对多的星状关联。</p><p>中介者模式由四个主要角色来构建，中介者接口（Mediator）定义公用交互方法changed(); 具体中介者（ConcreteMediator）实现具体的交互方法changed()，并且获取需要持有需要通信的colleague的引用，changed()方法的具体实现依赖于持有的colleague引用; 同事抽象类(Colleague)定义同事接口对中介者接口的关联关系，并且提供获取中介者的接口方法; 具体的同事实现类（ConcreteColleague）可能有多个，主要是实现具体的交互操作，交互操作依赖于其关联的中介者的changed方法。至于为什么说是变成了一对多的关系，从上面四个角色的关系来看，每个colleague都持有一个mediator的引用，而每个mediator持有所有colleage的引用。</p><p>中介者模式优点在于解耦复杂系统对象的交互，使得再增加或者删除colleage时仅需要修改中间的中介者。中介者也可以替换成另一个具体中介者，替换相应的交互行为。缺点之处在于随着需要交互同事的不断增加，具体中介者也会不断膨胀。</p><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>本文首发表于<a href="https://buwenqi.github.io" target="_blank" rel="external">Wenqi’s Blog</a>,更多技术分享欢迎关注！转载须注明文章出处，已委托维权骑士为本站的文章进行维权, 作者保留文章所有权。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很早就接触了设计模式，今天在看一些文章的时候发现自己在学习理解设计模式的时候有些偏差。设计模式应该服务于特定的场景，并且是经过前人经验总结而来的代码解决思路，这种解决思路考虑的点在于如何能够让代码之间的耦合度更低并且减少冗余，使得代码耦合度更低的目的是为了程序更好的扩展，所谓的更好的扩展是指在功能的变动或者扩展的情况下尽可能触发较少的改动。所以在学习设计模式的时候，一个好的学习方式应该是模拟程序的扩展来比较在使用前人总结的设计模式和现有代码的不同之处，只有真正体会到其优点，才能尽得其精髓。&lt;/p&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>机器学习总结系列之逻辑回归</title>
    <link href="http://yoursite.com/2018/02/23/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E7%B3%BB%E5%88%97%E4%B9%8B%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/"/>
    <id>http://yoursite.com/2018/02/23/机器学习总结系列之逻辑回归/</id>
    <published>2018-02-23T13:54:29.000Z</published>
    <updated>2018-03-29T09:03:44.283Z</updated>
    
    <content type="html"><![CDATA[<p>线性回归适合连续型的函数拟合任务（也就是回归任务），即对于不同的输入x，输出y所属于的域是一个连续的空间，而对于y是确定的离散的空间的分类任务，比如y只取0，1的二分类问题，仍然使用线性回归的直线拟合无法适应大量输入x而y只限制在0-1的情况，我们需要一种值域在0-1的函数来作为我们的假设函数。</p><a id="more"></a><p>这个函数就是被称为逻辑函数（Logistic Function）或者Sigmoid函数。它的函数表达式如下</p><p>\(g(z)=\frac&#123;1&#125;&#123;1+e^&#123;-z&#125;&#125;\)</p><p>它的函数图像如下图所示，整个值域在0-1，以z=0时函g(z)=0.5,<br><img src="https://i.imgur.com/cp47Nbg.png" alt=""></p><h2 id="假设函数"><a href="#假设函数" class="headerlink" title="假设函数"></a>假设函数</h2><p>基于以上，逻辑回归的假设函数是基于Sigmoid函数定义的，参数z是通过\(\theta^Tx\)来定义的，综合起来，其假设函数是</p><p>\(h_\theta(x)=g(\theta^Tx)=\frac&#123;1&#125;&#123;1+e^&#123;-\theta^Tx&#125;&#125;\)</p><p>并且和线性回归不同的是其假设函数不是最终y的值，而是使用x和\(\theta\)计算出的y=1情况的概率</p><p>\(h_\theta(x)=P(y=1|x;\theta)\)<br>\(h_\theta(x)&gt;=0.5,y=1\)<br>\(h_\theta(x)&lt;0.5,y=0\)</p><p>相比之下，线性回归计算的结果直接是y的值，而逻辑回归计算出来的是y=1的概率，如果这个概率大于0.5，我们就认为结果是1，反之则y=0。根据Sigmoid函数的定义，我们知道当\(\theta^T&gt;=0\)的时候\(h_\theta(x)&gt;=0.5\),我们把这条\(\theta^T&gt;=0\)称为<strong>决策边界（decision boundary）</strong></p><h2 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h2><p>如果我们想要想线性回归那样使用梯度下降来计算最优的参数\(\theta\),我们需要构造逻辑回归的损失函数。线性回归的损失函数是假设函数值和真实值平方差的平均值，像下面这样</p><p>\(J(\theta_0,\theta_1,\cdots,\theta_n)=&#123;&#123;1\over 2m&#125;(h_\theta(x^&#123;(i)&#125;)-y^&#123;(i)&#125;)^2&#125; \)</p><p>这样的一个原因是，如果假设函数的结果和真实结果相差的太大，那么损失函数的值也会增大，而梯度下降就是不断削减这个损失函数的过程。而逻辑回归的真实值y是离散的0和1，而假设函数\( h_\theta(x)\)是y等于1的概率，所以逻辑应该是这样的，当y=1而\( h_\theta(x)\)的概率越小时，损失函数应该变大，对应的，如果y=0而\( h_\theta(x)\)越大时，损失函数应该变大。所以逻辑回归用一个分段函数来表示其损失函数，其中log代表自然对数</p><p>\(Cost(h_\theta(x),y)=-log(h_\theta(x)),if(y=1)\)<br>\(Cost(h_\theta(x),y)=-log(1-h_\theta(x)),if(y=0)\)</p><p>这函数的函数图像如下<br><img src="https://i.imgur.com/TaMu6Jf.png" alt=""></p><p><img src="https://i.imgur.com/a2G8oGL.png" alt=""></p><p>那么其损失函数等于所有训练集的Cost函数和的平均值</p><p>\(J(\theta)=\frac&#123;1&#125;&#123;m&#125;\sum_&#123;i=1&#125;^m Cost(h_\theta(x),y)\)</p><p>我们可以将Cost分段函数写成一个函数</p><p>\(Cost(h_\theta(x),y)=-ylog(h_\theta(x))-(1-y)log(1-h_\theta(x))\)</p><p>\(J(\theta)=-\frac&#123;1&#125;&#123;m&#125;\sum_&#123;i=1&#125;^&#123;m&#125;[y^&#123;(i)&#125;log(h_\theta(x^&#123;(i)&#125;))+(1-y^&#123;(i)&#125;)log(1-h_\theta(x^&#123;(i)&#125;))]\)</p><p>有了损失函数\(J(\theta)\),我们的目标就是利用训练数据最小化\(J(\theta)\),使用梯度下降法取最优值，对\(J(\theta)\)求导过程如下<br><img src="https://i.imgur.com/4y1aKIb.jpg" alt=""><br>推到后其值为</p><p>\(\frac&#123;\partial&#125;&#123;\partial\theta_j&#125;=\frac&#123;1&#125;&#123;m&#125;\sum_&#123;i=1&#125;^&#123;m&#125;(h_\theta(x^&#123;i&#125;)-y^&#123;(i)&#125;)x_j^&#123;(i)&#125;\)</p><p>虽然这里的求导后和线性回归的形式一样，但是这里的\(h_\theta(x)=\frac&#123;1&#125;&#123;1+e^&#123;-\theta^Tx&#125;&#125;\),和线性回归是不同的</p><p>其优化过程就是迭代的更新\(\theta\),也就是</p><p>\(\theta_j=\theta_j-\alpha \frac&#123;\partial&#125;&#123;\partial\theta_j&#125;\)<br>\(\theta_j=\theta_j-\alpha \frac&#123;1&#125;&#123;m&#125;\sum_&#123;i=1&#125;^&#123;m&#125;(h_\theta(x^&#123;i&#125;)-y^&#123;(i)&#125;)x_j^&#123;(i)&#125;\)</p><p>我们可以自己实现梯度下降，也可以使用内置的优化函数fminunc来进行优化，其使用有三步</p><ol><li>给出迭代每一步的计算函数function [jval,gradient]=costFunction(theta)</li><li>给出迭代的选项设置对象options=optimset(‘GradObj’,’on’,’MaxIter’,100)和初始的initialTheta</li><li>使用fminunc获取结果：<br>[optTheta,functionVal,exitFlag]=fminunc(@costFunction,initialTheta,options)</li></ol><h2 id="多分类问题"><a href="#多分类问题" class="headerlink" title="多分类问题"></a>多分类问题</h2><p>多分类问题可以通过二分类问题推广而来，假设有n种分类，那么我们可以对每一个种类训练一个逻辑回归函数，然后取其中的最大值作为分类结果<br>Class 1:\(h_\theta^&#123;(1)&#125;(x)=P(y=1|x;\theta)\)<br>Class 2:\(h_\theta^&#123;(2)&#125;(x)=P(y=2|x;\theta)\)<br>Class 3:\(h_\theta^&#123;(3)&#125;(x)=P(y=3|x;\theta)\)<br>取\(max(h_\theta^&#123;(i)&#125;)\)为最终结果</p><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>本文首发表于<a href="https://buwenqi.github.io" target="_blank" rel="external">Wenqi’s Blog</a>，更多技术分享欢迎关注！转载须注明文章出处，已委托维权骑士为本站的文章进行维权，作者保留文章所有权。</p><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;线性回归适合连续型的函数拟合任务（也就是回归任务），即对于不同的输入x，输出y所属于的域是一个连续的空间，而对于y是确定的离散的空间的分类任务，比如y只取0，1的二分类问题，仍然使用线性回归的直线拟合无法适应大量输入x而y只限制在0-1的情况，我们需要一种值域在0-1的函数来作为我们的假设函数。&lt;/p&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>机器学习总结系列之Octave常用操作</title>
    <link href="http://yoursite.com/2018/02/23/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E7%B3%BB%E5%88%97%E4%B9%8BOctave%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2018/02/23/机器学习总结系列之Octave常用操作/</id>
    <published>2018-02-23T12:49:42.000Z</published>
    <updated>2018-02-23T13:33:35.380Z</updated>
    
    <content type="html"><![CDATA[<p>记录了常用的或难记的一些Octave命令，以备查找。<br><a id="more"></a></p><h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><ul><li>eye(4),生成一个4维单位矩阵</li><li>ones(4，3),生成全1的4*3矩阵</li><li>rand(4,3),生成一个4*3的随机矩阵</li><li>size(A),返回一个行向量，代表行列</li><li>length(A),返回最大维的那个数目</li><li>help cmd,查看命令详情</li></ul><h2 id="加载数据"><a href="#加载数据" class="headerlink" title="加载数据"></a>加载数据</h2><ul><li>load(“filename”)或load filename,将文件数据加载到对应的矩阵，矩阵名和filename一样</li><li>save filename matrixVariable –asciii，将矩阵存到文件中</li><li>who，显示当前所有的矩阵</li><li>whos，详细显示当前所有的矩阵（常用）</li><li>clear，清除当前上下文的所有矩阵变量</li><li>矩阵切片<ul><li>下标从1开始，两数字之间用：代表范围，直接用：代表所有，例如A为10x4的矩阵</li><li>A(2,:)代表取第二行，A(2:4,:)代表取2到4行，A([2,4],:)代表取第二和第四行</li><li>聚合A=[A,[1;1;1;1]]，加一列</li></ul></li></ul><h2 id="矩阵运算"><a href="#矩阵运算" class="headerlink" title="矩阵运算"></a>矩阵运算</h2><ul><li>A*B是矩阵乘法，A.*B是点乘运算，点乘A和B是同型矩阵，对应相乘</li><li>同样的A.^2的意思是每个元素取平方形成新的矩阵</li><li>1+A等同于每个矩阵元素加1</li><li>A&lt;3,返回0和1的矩阵</li><li>[row,column]=find(A&lt;3),返回元素小于3的行列值</li><li>A’,A的转置矩阵</li><li>log(A),矩阵A每个元素取自然对数</li><li>exp(A)，矩阵A每个元素的自然指数e</li><li>abas(A),矩阵A每个元素取绝对值</li><li>sum(A),每列相加，返回行向量</li><li>[x,ix]=max(A,[],1)，选取每列最大值存到x中，行索引存在ix中</li><li>pinv(A)，求A的逆矩阵</li></ul><h2 id="画图"><a href="#画图" class="headerlink" title="画图"></a>画图</h2><ul><li>plot(x轴数据，y轴数据)</li><li>hold on;不关闭画窗，继续编辑</li><li>print -dpdf “name”;画好保存</li><li>subplot(1,2,1)在一张1x2的画布上开始画第一个子图</li></ul><h2 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h2><blockquote><ul><li>indices=1:10;<br>for i=indices,<br>v(i)=2^i;<br>end;</li><li>while i&lt;=5,<br>do sth.<br>i=i+1;<br>end;</li><li>if condition,<br>do sth.<br>elseif condition,<br>do sth.<br>else<br>do sth.<br>end;</li></ul></blockquote><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>function [返回值列表]=函数名(参数列表)<br>% 注释<br>直接为返回值列表参数赋值<br>函数名最好和文件名相同</p><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>本文首发表于<a href="https://buwenqi.github.io" target="_blank" rel="external">Wenqi’s Blog</a>,更多技术分享欢迎关注！转载须注明文章出处，已委托维权骑士为本站的文章进行维权, 作者保留文章所有权。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录了常用的或难记的一些Octave命令，以备查找。&lt;br&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>机器学习总结系列之Introduction</title>
    <link href="http://yoursite.com/2018/02/19/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E7%B3%BB%E5%88%97%E4%B9%8BIntroduction/"/>
    <id>http://yoursite.com/2018/02/19/机器学习总结系列之Introduction/</id>
    <published>2018-02-19T01:58:59.000Z</published>
    <updated>2018-03-29T08:51:10.186Z</updated>
    
    <content type="html"><![CDATA[<p>人工智能在如今无疑是如日中天，它的各个子领域也因此得到了极大的发展，<strong>机器学习</strong>作为人工智能的一个子领域以赋予机器以人类特有的学习能力也得以大放异彩，它被应用在各个领域，典型的例子如个性化推荐，数据挖掘，垃圾邮件识别等等，机器学习算法和传统算法的不同之处在于传统算法研究的是如何解决一个有特定结果的问题，而机器学习算法则是挖掘数据中潜在的规律，然后对输入做出预测。按1959年Arthur Samuel的说法来说，机器学习领域研究的是如何赋予计算机解决不能被明确编程解决的问题的学习能力。<br><a id="more"></a></p><blockquote><p>Machine Learning: Field of study that gives computers the ability to learn without being explicitly programmed. –Arthur Samuel.</p></blockquote><p>从学习的方式来看，机器学习分为监督学习（Supervised Learning）和非监督学习（Unsupervised Learning）, 两者的区别是学习的数据集是否含有已经标注好的标记。<br>从学习的结果来看，监督学习分为分类（Classification）和回归（Regresssion）两种,分类是相对于离散型的输出值，而回归相对的是连续型的输出值。非监督学习更多的是聚类型问题。</p><h2 id="模型的表示"><a href="#模型的表示" class="headerlink" title="模型的表示"></a>模型的表示</h2><p>习惯性的字母表示的含义</p><ol><li>m，代表训练数据记录的条数</li><li>n，每条训练数据具有的属性数，也就是每条训练数据的维数</li><li>\( x\)，代表输入集，\(x^&#123;(i)&#125;\)代表输入集的第i条记录，\(x_j^&#123;(i)&#125;\)代表第i条记录的第j个属性</li><li>\(y\)，代表输出集</li></ol><h2 id="单变量的线性回归（Linear-regression-with-one-variable）"><a href="#单变量的线性回归（Linear-regression-with-one-variable）" class="headerlink" title="单变量的线性回归（Linear regression with one variable）"></a>单变量的线性回归（Linear regression with one variable）</h2><p>单变量的线性回归<strong>假设函数</strong>（Hypothesis）: \(h_\theta(x)=\theta_0+\theta_1 x\)<br>所谓单变量是值输入变量仅有x一个，而我们的最终的目标是通过现有的已有标记的训练数据（有x和y对应的值），来找出最好的线性参数\(\theta_0,\theta_1\)使得这条直线最好拟合训练数据，以期这个函数对新的输入x有接近正确的输出。从这个角度来说，我们是在寻找训练数据中的规律，并用线性函数进行刻画。那么我们应该如何选择\(\theta_0,\theta_1\)呢？</p><p>这里提出一个概念<strong>损失函数</strong>（Cost Function）,所谓损失函数是指我们的\(h_\theta(x)\)计算出来的值和已知的值之间的差的均值，表示处理便是如下公式：</p><p>\(J(\theta_0,\theta_1)=&#123;&#123;1\over 2m&#125;(h_\theta(x^&#123;(i)&#125;)-y^&#123;(i)&#125;)^2&#125; \)</p><p>当然，我们希望这个值越小越好，因为这个值越小，说明我们拟合的\(h_\theta(x)\)跟训练集中数据的相差很小，那么我们用\(h_\theta(x)\)推断新的x的对应的y值就越精确，那么，如何获得对应的的\(\theta_0,\theta_1\)使得\(J(\theta_0,\theta_1)\)最小呢？</p><p>一提到最小化问题，我们立即会想到导数，最优化算法中一个经典的迭代算法叫做<strong>梯度下降</strong>（Gradient Descent）,我们可以用这个算法来获取\(J(\theta_0,\theta_1)\)取最小值时的\(\theta_0,\theta_1\)。梯度下降的基本原理是朝着梯度的反方向走，那么如果函数是凸函数的话经过多次迭代后就会区域收敛，取得最小值。而梯度的值是对应变量在目标函数上的偏导数组成的向量，如果我们想要朝着梯度的反方向走，只要减去沿着梯度方向的向量值即可。根据这个思想，我们可以归结出使用梯度下降来更新\(\theta\)值的方法，也就是：</p><p>\( \theta_j=\theta_j-&#123;\alpha&#125;&#123;\frac&#123;\partial&#125;&#123;\partial \theta_j&#125;J(\theta_0,\theta_1)&#125;\)<br>\( \frac&#123;\partial&#125;&#123;\partial \theta_j&#125;J(\theta_0,\theta_1)=&#123;\frac&#123;1&#125;&#123;m&#125;&#123;\sum_&#123;i=1&#125;^&#123;m&#125;(h_\theta(x^&#123;(i)&#125;)-y^&#123;(i)&#125;)x^i&#125;&#125;\)<br>\(\Rightarrow\)<br>\( \theta_j=\theta_j-&#123;\alpha&#125;&#123;\frac&#123;1&#125;&#123;m&#125;&#123;\sum_&#123;i=1&#125;^&#123;m&#125;(h_\theta(x^&#123;(i)&#125;)-y^&#123;(i)&#125;)x^i&#125;&#125;\)</p><p>其中\(\alpha\)为下降速率，不可太小或太大，太小会导致下降速度过慢，太大会导致不收敛。并且所有的\(\theta\)要同步更新。</p><h2 id="多变量的线性回归（Linear-regression-with-multiple-variables）"><a href="#多变量的线性回归（Linear-regression-with-multiple-variables）" class="headerlink" title="多变量的线性回归（Linear regression with multiple variables）"></a>多变量的线性回归（Linear regression with multiple variables）</h2><p>单一变量的线性回归仅仅有一维输入数据x，这里扩展到更为常见的具有多维的输入数据，相应的，我们的多变量的线性回归的假设函数变成：</p><p>\( h_\theta(x)=\theta^&#123;T&#125;x=\theta_0x_0+\theta_1x_1+\theta_2x_2+\cdots+\theta_nx_n\)</p><p>其中，为了向量化方便计算，将\(x_0\)固定化为1,也就是在处理数据之前要加入一列1取得对\(\theta_0\)常数项的值。其中\(\vec&#123;\theta&#125;\)的维数为n+1。<br>其损失函数也一样：</p><p>\(J(\theta_0,\theta_1,\cdots,\theta_n)=&#123;&#123;1\over 2m&#125;(h_\theta(x^&#123;(i)&#125;)-y^&#123;(i)&#125;)^2&#125; \)</p><p>使用梯度下降法来迭代更新</p><p>\( \theta_j=\theta_j-&#123;\alpha&#125;&#123;\frac&#123;\partial&#125;&#123;\partial \theta_j&#125;J(\theta_0,\theta_1)&#125;\)<br>\( \frac&#123;\partial&#125;&#123;\partial \theta_j&#125;J(\vec&#123;\theta&#125;)=&#123;\frac&#123;1&#125;&#123;m&#125;&#123;\sum_&#123;i=1&#125;^&#123;m&#125;(h_\theta(x^&#123;(i)&#125;)-y^&#123;(i)&#125;)x_j^i&#125;&#125;\)<br>\(\Rightarrow\)<br>\( \theta_j=\theta_j-&#123;\alpha&#125;&#123;\frac&#123;1&#125;&#123;m&#125;&#123;\sum_&#123;i=1&#125;^&#123;m&#125;(h_\theta(x^&#123;(i)&#125;)-y^&#123;(i)&#125;)x_j^i&#125;&#125;\)</p><p>这里后面\(\theta_j\)的偏导数依赖于\(x_j\),对于矩阵X来说，\(x_0^i=1\)所以\(\theta_0\)的更新和其他一样<br>\( \theta_0=\theta_0-&#123;\alpha&#125;&#123;\frac&#123;1&#125;&#123;m&#125;&#123;\sum_&#123;i=1&#125;^&#123;m&#125;(h_\theta(x^&#123;(i)&#125;)-y^&#123;(i)&#125;)x_0^i&#125;&#125;\)</p><h2 id="特征缩放（Feature-Scaling）和平均正则化（Mean-Normalization）"><a href="#特征缩放（Feature-Scaling）和平均正则化（Mean-Normalization）" class="headerlink" title="特征缩放（Feature Scaling）和平均正则化（Mean Normalization）"></a>特征缩放（Feature Scaling）和平均正则化（Mean Normalization）</h2><p>特征缩放和平均正则化解决的是特征之间相差比例太大，导致梯度下降速度过慢的问题，通过这两种方式使得特征属性变成同一范围内，当然这个包括我们加入的辅助特征\(x_0=1\)。具体的操作方法是</p><p>\(\frac&#123;(x_i-平均值)&#125;&#123;标准差或(最大值-最小值)&#125;\)</p><h2 id="多项式回归（Polynomial-Regression）"><a href="#多项式回归（Polynomial-Regression）" class="headerlink" title="多项式回归（Polynomial Regression）"></a>多项式回归（Polynomial Regression）</h2><p>我们线性回归的思路使用较少的变量之间的乘积组合，形成非线性的假设函数，例如二次方程，三次方程，一个具有一维特征的例子如下:</p><p>\(h_\theta(x)=\theta_0+\theta_1x_1+\theta_2x_1^2\)</p><h2 id="正则化方程式（Normal-Equation）"><a href="#正则化方程式（Normal-Equation）" class="headerlink" title="正则化方程式（Normal Equation）"></a>正则化方程式（Normal Equation）</h2><p>正则化方程式求解\(\vec&#123;\theta&#125;\)适用于训练矩阵X维数不超过10000的情况，这种情况下可以通过一下公式进行求解</p><p>\(\vec&#123;\theta&#125;=(X^TX)^&#123;-1&#125;X^Ty\)</p><h2 id="使用向量乘法来代替求和"><a href="#使用向量乘法来代替求和" class="headerlink" title="使用向量乘法来代替求和"></a>使用向量乘法来代替求和</h2><p>机器学习算法大量使用矩阵之间的运算，使用向量化的方法计算求和使得实现起来更为简洁明了，避免使用繁琐的for循环，下面举几个常用的例子以显示其优点：</p><p>\( h_\theta(x)=\sum_&#123;j=0&#125;^&#123;n&#125;&#123;\theta_j x_j&#125;=\theta^T x\)</p><p>梯度下降：</p><p>\( \theta_0=\theta_0-&#123;\alpha&#125;&#123;\frac&#123;1&#125;&#123;m&#125;&#123;\sum_&#123;i=1&#125;^&#123;m&#125;(h_\theta(x^&#123;(i)&#125;)-y^&#123;(i)&#125;)x_0^i&#125;&#125;\)<br>\( \theta_1=\theta_1-&#123;\alpha&#125;&#123;\frac&#123;1&#125;&#123;m&#125;&#123;\sum_&#123;i=1&#125;^&#123;m&#125;(h_\theta(x^&#123;(i)&#125;)-y^&#123;(i)&#125;)x_1^i&#125;&#125;\)<br>\( \theta_2=\theta_2-&#123;\alpha&#125;&#123;\frac&#123;1&#125;&#123;m&#125;&#123;\sum_&#123;i=1&#125;^&#123;m&#125;(h_\theta(x^&#123;(i)&#125;)-y^&#123;(i)&#125;)x_2^i&#125;&#125;\)<br>\(\Rightarrow\)<br>\( \vec&#123;\theta&#125;=\vec&#123;\theta&#125;-\alpha&#123;\frac&#123;1&#125;&#123;m&#125;X^T(h_\theta(x)-y)&#125;\)</p><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>本文首发表于<a href="https://buwenqi.github.io" target="_blank" rel="external">Wenqi’s Blog</a>,更多技术分享欢迎关注！转载须注明文章出处，已委托维权骑士为本站的文章进行维权, 作者保留文章所有权。</p><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;人工智能在如今无疑是如日中天，它的各个子领域也因此得到了极大的发展，&lt;strong&gt;机器学习&lt;/strong&gt;作为人工智能的一个子领域以赋予机器以人类特有的学习能力也得以大放异彩，它被应用在各个领域，典型的例子如个性化推荐，数据挖掘，垃圾邮件识别等等，机器学习算法和传统算法的不同之处在于传统算法研究的是如何解决一个有特定结果的问题，而机器学习算法则是挖掘数据中潜在的规律，然后对输入做出预测。按1959年Arthur Samuel的说法来说，机器学习领域研究的是如何赋予计算机解决不能被明确编程解决的问题的学习能力。&lt;br&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>python和shell基础语法对比</title>
    <link href="http://yoursite.com/2018/01/12/python%E5%92%8Cshell%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E5%AF%B9%E6%AF%94/"/>
    <id>http://yoursite.com/2018/01/12/python和shell基础语法对比/</id>
    <published>2018-01-12T07:56:48.000Z</published>
    <updated>2018-02-21T14:26:34.728Z</updated>
    
    <content type="html"><![CDATA[<p>python和shell都是我们经常使用的脚本语言，平时python主要用来写一些小型的任务，shell则在使用liunx系统部署任务的时候用的比较多，由于两者有一些相似之处，时间长了容易混掉，所以这里作文对一些基础的语法需求总结、比较、归纳，以为后用。<br><a id="more"></a></p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>python定义和使用只需要使用变量名，例如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var=“hello”</div><div class="line">print var</div><div class="line"># hello</div></pre></td></tr></table></figure></p><p>shell定义变量只需要变量名，而使用变量的值则需要加$符号，例如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var=&quot;hello&quot;</div><div class="line">echo $var</div><div class="line"># hello</div></pre></td></tr></table></figure></p><h2 id="数组的定义"><a href="#数组的定义" class="headerlink" title="数组的定义"></a>数组的定义</h2><p>python中没有数组的概念，但是有list，tuple，dict等可以代替其功能，声明一个list并使用其中的一个元素如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">numbers=[1,2,3,4,5]</div><div class="line">print numbers[0]</div><div class="line"># 1</div></pre></td></tr></table></figure></p><p>shell中只有一维数组，其声明和使用方法如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">numbers=(1 2 3 4 5)</div><div class="line">print $&#123;numbers[0]&#125;</div><div class="line"># 1</div><div class="line">#返回所有的值用</div><div class="line">print $&#123;numbers[*]&#125;</div><div class="line"># 1 2 3 4 5</div></pre></td></tr></table></figure></p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>python和shell都可以是用#号添加单行注释，python可以使用’’’注释’’’添加多行注释</p><h2 id="逻辑判断"><a href="#逻辑判断" class="headerlink" title="逻辑判断"></a>逻辑判断</h2><h3 id="条件的定义"><a href="#条件的定义" class="headerlink" title="条件的定义"></a>条件的定义</h3><p>在python中，除了所有的空值被认为False外所有的值都被解释为真True，这里的空值包括：None,0,””,(),{},[]和False,下面是例子<br><img src="https://i.imgur.com/oIbXM8v.png" alt=""><br>其他的由比较运算符进行比较支持，其中比较特殊的操作符有</p><ul><li>x is y    x和y是同一个对象</li><li>x is not y</li><li>x in y    x在y集合中</li><li>x not in y</li></ul><p>逻辑预算法用and,or,not.</p><p>而shell的理念大不相同，它使用test命令来进行条件测试，它通常写成[ condition ]的形式，注意方括号两边都要有空格，它支持三类测试：</p><ul><li>数值比较，需要用-eq,-gt来代替==，&gt;</li><li>字符串比较，可以用=，需要用-n之类的短命令，比如-n str来判定str长度是否非零</li><li>文件比较，需要用短命令,例如-e file判断文件是否存在</li></ul><p>逻辑运算符&amp;&amp;，||来连接不同的[ condition ]</p><p>另外，高级的数学表达式推荐使用(( expression ))逻辑判定，可以使用自增++，位移运算符&lt;&lt;,位运算符&amp;，逻辑与&amp;&amp;等等<br>高级的字符串判定使用[[ expression ]]逻辑判定，可以用类似于正则表达式如[[ $teststr== r* ]]判定以r开头的字符串<br>shell的数值运算推荐使用$[expression]的方式计算，浮点数的计算使用echo “expression”| bc的方式获取计算值</p><h3 id="if-else"><a href="#if-else" class="headerlink" title="if else"></a>if else</h3><p>python中的if else使用方式如下，条件语句后加冒号，并且以缩进划分语句块<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">if condition:</div><div class="line">statement</div><div class="line">elif condition:</div><div class="line">statement</div><div class="line">else:</div><div class="line">statement</div></pre></td></tr></table></figure></p><p>shell中则不同，其if else使用方式如下,它使用then和elseif或fi来界定语句块，理论上不需要缩进<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">if [ condtion ]</div><div class="line">then</div><div class="line"> statement</div><div class="line">elif [condtion]</div><div class="line">then</div><div class="line"> statement</div><div class="line">else</div><div class="line"> statement</div><div class="line">fi</div></pre></td></tr></table></figure></p><h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><p>python的for循环使用如下,仍然用缩进划分语句块<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">for item in sequence:</div><div class="line">statement</div></pre></td></tr></table></figure></p><p>shell中for的使用方式类似<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">for item in list</div><div class="line">do</div><div class="line">statement</div><div class="line">done</div></pre></td></tr></table></figure></p><p>其中shell取item的分隔符全局变量为IFS（internal field separator），其默认值为空格，制表符，换行符，所以如果需要按行处理而忽略空格的话需要改变IFS的值<br>另外shell还支持c语言形式的for循环，它使用双小括号来完成，形式如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">for (( i=1; i&lt;=10;i++))</div><div class="line">do</div><div class="line"> statement</div><div class="line">done</div></pre></td></tr></table></figure></p><h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><p>python的while写法如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">while condition:</div><div class="line">statement</div></pre></td></tr></table></figure></p><p>shell的while写法如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">while [ conditon ]</div><div class="line">do</div><div class="line"> statement</div><div class="line">done</div></pre></td></tr></table></figure></p><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>python的异常处理方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">try:</div><div class="line">statement</div><div class="line">except:</div><div class="line">statement</div><div class="line">finally:</div><div class="line">finalStatement</div></pre></td></tr></table></figure></p><p>shell中没有相应的异常处理机制，只有每条命名的错误输出描述符2，可以通过2&gt;&amp;1将错误输出重定向到标准输出</p><h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><p>python使用open函数，其有读写模式有只读r,只写w,添加a<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">myfile=open(&quot;filename&quot;,&quot;r&quot;)</div><div class="line">myfile.readlines()</div><div class="line">myfile.close()</div><div class="line">with open(&quot;finename&quot;,&quot;w&quot;) as myfile:</div><div class="line">myfile.write(&quot;line\n&quot;)</div></pre></td></tr></table></figure></p><p>shell读取文件的内容使用命令来读取，然后使用管道或者重定向进行输入处理，常用的命令有</p><ol><li>cat filename 读取文件的全部内容</li><li>tail -n 2 filename读取尾两行</li><li>head -n 2 filename读取前两行</li></ol><p>一个经典的问题，读取一个文件中的每一行做处理，使用python很简单<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">with open(&quot;filename&quot;,&quot;r&quot;) as myfile:</div><div class="line">for line in myfile.readlines():</div><div class="line">print line</div></pre></td></tr></table></figure></p><p>使用shell<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">cat filename|while read line</div><div class="line">do</div><div class="line">echo $line</div><div class="line">done</div><div class="line">#或者</div><div class="line">IFS=&apos;\n&apos;</div><div class="line">for line in `cat  filename`</div><div class="line">do</div><div class="line">echo $line</div><div class="line">done</div></pre></td></tr></table></figure></p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>python的函数如下形式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">def functionname(params):</div><div class="line">&apos;函数文档&apos;</div><div class="line">statement</div><div class="line">return value</div></pre></td></tr></table></figure></p><p>其中函数文档可以通过functionname.<strong>doc</strong>获得<br>shell中函数形式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function functionname &#123;</div><div class="line">commands</div><div class="line">return value</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>使用变量获取返回值，参数通过函数<code>functionname param1 param2</code>的方式传递，通过$1,$2的方式取出第一第二个参数，$#为参数数量，$*为所有参数。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>本文首发表于<a href="https://buwenqi.github.io" target="_blank" rel="external">我的博客</a>,欢迎关注！转载须注明文章出处，作者保留文章所有权。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;python和shell都是我们经常使用的脚本语言，平时python主要用来写一些小型的任务，shell则在使用liunx系统部署任务的时候用的比较多，由于两者有一些相似之处，时间长了容易混掉，所以这里作文对一些基础的语法需求总结、比较、归纳，以为后用。&lt;br&gt;
    
    </summary>
    
    
      <category term="脚本语言" scheme="http://yoursite.com/tags/%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>深入理解红黑树原理与实现</title>
    <link href="http://yoursite.com/2018/01/02/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E7%BA%A2%E9%BB%91%E6%A0%91%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/2018/01/02/深入理解红黑树原理与实现/</id>
    <published>2018-01-02T06:10:04.000Z</published>
    <updated>2019-07-02T14:15:30.174Z</updated>
    
    <content type="html"><![CDATA[<p>红黑树(RBTree)是一种相比平衡二叉树(AVL)平衡要求较低的的一种二叉搜索树，所谓平衡要求较低的意思是相比AVL树的每个节点的左右子树的高度差不能超过2，红黑树使用红黑两种颜色来标记二叉搜索树中的节点，并对这种着色进行限制，使得在插入删除操作后对不符合的情况必须进行调整来保持这样一种限制，从而实现自我平衡。我们先来看一下红黑树的定义，也就是着色限制<br><a id="more"></a></p><ul><li>每个节点必须着色成红色或者黑色</li><li>根节点是黑色的</li><li>空节点是黑色的</li><li>父子节点之间不能出现两个连续的红色节点</li><li>每个节点到其后代叶子节点的所有路径上均包含相同数目的黑色节点(一个节点出发的所有路径的黑高相同)</li></ul><p>通过这样的限制，红黑树可以实现没有一条路径会比最短路径长出两倍，相比AVL树来说平衡要求较低，这种低要求换来的是更高效的调整操作，红黑树可能仅需要进行局部的调整，而AVL树必须要回溯到根节点进行信息更新，这是红黑树的优势，并且红黑树的统计效率比AVL树好，有大量的工程项目已经在实际的使用这种数据结构存储数据，例如Java 8中的HashMap在处理冲突的时候就采用了红黑树代替了原来的链表以加快查询速度。</p><h2 id="节点的定义"><a href="#节点的定义" class="headerlink" title="节点的定义"></a>节点的定义</h2><p>除了常规的左右子节点，因为我们在插入删除的时候经常需要进行查找当前节点的父节点，所以我们需要一个父节点信息，然后还有一个颜色信息，我们只需要一个Byte就可以指示当前节点是红色还是黑色，红色我们用0来表示，黑色用1来表示，其节点信息如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RBNode</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">T element;</div><div class="line">RBNode&lt;T&gt; left;</div><div class="line">RBNode&lt;T&gt; right;</div><div class="line">RBNode&lt;T&gt; parent;</div><div class="line"><span class="keyword">byte</span> color;<span class="comment">//0为红色，1为黑色</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">RBNode</span><span class="params">(T x)</span> </span>&#123;</div><div class="line"><span class="keyword">this</span>.element=x;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>另外我们还在RBTree构造方法里初始化了一个全局的nullNode，颜色为黑色，目的是简化繁杂的判空操作，它可以像正常节点一样，只是它的作用仅限于一下两点：</p><ul><li>root的父节点指向nullNode</li><li>树中节点原来指向空指针的地方用nullNode代替</li></ul><p>nullNode自身的left，right，parent可以指向任何地方，可以在有需要的时候进行分配，也可以弃之不用，关于nullNode使用到的地方我会在最后进行总结。</p><h2 id="基本的旋转操作"><a href="#基本的旋转操作" class="headerlink" title="基本的旋转操作"></a>基本的旋转操作</h2><p>旋转操作是恢复红黑树性质的一条基本操作，它包括将一个当前节点的右孩子提到当前节点旋转到当前节点的位置，也就是左旋，对称的是将将当前节点的左孩子旋转到当前节点的位置，也就是右旋，我们用前一种情况作为例子进行分析，我们把它命名为rotateWithRightChild,整个转换过称如图所示，其中转换前图的红色标记为断开的链的序列，转换后图的红色标记为对应断开的链接序列重新修复的链接。<br><img src="https://i.imgur.com/Hp41oWl.png" alt=""><br>这里采用的断链的序列根据关系对来确定的，比如说p和x1之间的断开修复关系为1,2;p和x的关系修复为3,4两条，x和g的关系修复是5,6两条，在没有图示的情况下这样是比较直观想象的，如果是画出的图例，我们也可以根据每个节点进行逐一修复，比如p的parent和child修复，x的parent,child修复，g的child修复，x1的parent修复，这样的方式进行也是可以的。<br>另外我们还需要考虑nullNode的情况，那么哪里会出现nullNode呢？p和x不可能，这是由rotateWithRightChild的适用环境所决定的，而x1和g可能为nullNode, 如果x1为nullNode，旋转后x1的parent指向了p，这并不会造成不良的后果，所以可以不予考虑，而如果g是nullNode，则说明p是root，旋转结束后就需要将x置为新根，这是一个必选的操作，不然root还是p。<br>基于以上考虑此我们有如下代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 旋转父节点p的右儿子到p的位置</div><div class="line"> * <span class="doctag">@param</span> p</div><div class="line"> * <span class="doctag">@return</span> </div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotateWithRightChild</span><span class="params">(RBNode&lt;T&gt; p)</span></span>&#123;</div><div class="line">RBNode&lt;T&gt; x=p.right;</div><div class="line">RBNode&lt;T&gt; g=p.parent;</div><div class="line"><span class="comment">//break1: p的右换指，同时改父指针</span></div><div class="line"><span class="comment">//tip1: x.left可能为nullNode,因为在处理的过程中对nullNode的parent</span></div><div class="line"><span class="comment">//可以是任意值，所以这里不做处理</span></div><div class="line">p.right=x.left;</div><div class="line">x.left.parent=p;</div><div class="line"><span class="comment">//break2: x的左换指，同时改父指针</span></div><div class="line">x.left=p;</div><div class="line">p.parent=x;</div><div class="line"></div><div class="line"><span class="comment">//break3: g的孩子更换为x</span></div><div class="line"><span class="comment">//tip2: g为nullNode,说明p为root,旋转需要换新根</span></div><div class="line"><span class="keyword">if</span>(g==nullNode) &#123;</div><div class="line">root=x;<span class="comment">//旋转后换新根</span></div><div class="line">root.parent=nullNode;</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span>(g.left==p) &#123;</div><div class="line">g.left=x;</div><div class="line">x.parent=g;</div><div class="line">&#125;<span class="keyword">else</span> &#123;</div><div class="line">g.right=x;</div><div class="line">x.parent=g;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>对称的你可以写出rotateWithLeftChild，思路是一样的。</p><h2 id="红黑树的插入"><a href="#红黑树的插入" class="headerlink" title="红黑树的插入"></a>红黑树的插入</h2><p>插入和删除是一个树的基本操作，对于有着色现在的红黑树来说，插入和删除都有可能引起红黑树着色限制的破坏，如何在插入和删除之后进行调整以维持红黑树的性质是红黑树实现的关键也是难点，这一节我们来探讨红黑树的插入。<br>我们插入的新节点总是红色的，原因是如果插入的节点是黑色的，那么必定会导致一条路径上的黑高增加一，每次插入必须进行调整，而如果插入节点是红色，而其父节点是黑色的话就可以不用调整。所以，我们选择插入红色的节点，在调整之前的插入逻辑和二叉查找树的插入是一样的，唯一不同的是需要在插入后如果插入节点的父节点是红色的话，会出现<strong>红红冲突</strong>，违反第四条限制规则，需要进行调整。下面是插入逻辑<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 输入一个节点值为x到红黑树根root中</div><div class="line"> * <span class="doctag">@param</span> x</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(T x)</span> </span>&#123;</div><div class="line">RBNode&lt;T&gt; p,cur;</div><div class="line">p=nullNode;<span class="comment">//p指向cur的父节点</span></div><div class="line">cur=root;</div><div class="line"><span class="keyword">while</span>(cur!=nullNode) &#123;</div><div class="line">p=cur;</div><div class="line"><span class="keyword">if</span>(x.compareTo(cur.element)&lt;<span class="number">0</span>)</div><div class="line">cur=cur.left;</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span>(x.compareTo(cur.element)&gt;<span class="number">0</span>)</div><div class="line">cur=cur.right;</div><div class="line"><span class="keyword">else</span> <span class="comment">//找到重复的，不需要进行进一步操作</span></div><div class="line"><span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//此时p位置即为插入位置的父节点</span></div><div class="line">RBNode&lt;T&gt; newX=getNewNode(x);<span class="comment">//新生成的节点为红色</span></div><div class="line">newX.parent=p;<span class="comment">//即便p为nullNode也是符合的</span></div><div class="line"><span class="keyword">if</span>(p==nullNode) &#123;</div><div class="line">root=newX;</div><div class="line">root.color=<span class="number">1</span>;</div><div class="line"><span class="keyword">return</span>;<span class="comment">//如果是根的话可以直接返回</span></div><div class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(x.compareTo(p.element)&lt;<span class="number">0</span>) &#123;</div><div class="line">p.left=newX;</div><div class="line">&#125;<span class="keyword">else</span> &#123;</div><div class="line">p.right=newX;</div><div class="line">&#125;</div><div class="line"><span class="comment">//插入完毕，开始调整红色新插入的x节点</span></div><div class="line"><span class="keyword">if</span> (p.color==<span class="number">1</span>) <span class="comment">//其父节点是黑色，插入完毕</span></div><div class="line"><span class="keyword">return</span>;</div><div class="line"><span class="keyword">else</span> <span class="comment">//红红冲突，进行调整</span></div><div class="line">insertBalance(newX);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>那么问题转换到如何在出现红红冲突的时候如何进行调整？处理这个问题的一个思路是能否想办法将插入节点x的父节点p变成黑色，这样解决了红红冲突，但是又造成了第五条黑高不同问题，如果能够在保持黑高不变的情况下将p变成黑色就好了。<br>哎~，p的父节点肯定是黑色的(不然有红红冲突)，我们可以将p的父节点g的黑色交给p,g变成红色，然后将p旋转到g的位置，这样不就行了，黑高没有变换，而且消除了p和x之间的红红冲突。基本思路是这样，但是我们还是要考虑一些细节，以验证这个想法是否合适，首先g变成了红色，g除了p之外的另一个孩子w,也就是p的兄弟节点如果是红色的，我们的这种调整会造成g和w之间的红红冲突，所以，如果w是红色的我们不能进行这种调整。<br>如果是w是黑色的，我们就没有了这方面的顾虑，旋转操作除了g变色的影响，还有链接的变化，假设p是g的左孩子，x是p的右孩子（之字形），则进行g和p旋后x就会变成g的左孩子,x是红色的，而g也是红色的，这也引入的新的红红冲突，这是我们不想要的；而如果x是p的左孩子呢（一字型），这种变色+旋转操作后x仍是p的左孩子，p变成了黑色，p和x的红红冲突解决，并且没有引入新的红红冲突，黑高也没有改变，看来一字型的情况只需要变色+旋转就可以完成整个调整，使得这个树符合红黑树的结构。<br>总结来说，我们有一下三种情况（x-红为新插入节点，p-红为x父节点，g为p的父节点，w为p的兄弟节点，假设p为g的左孩子，右孩子的情况可以对称推出）：</p><ul><li>w为红色,则只需要g的黑色 (由p为红色推出g必为黑色) 分给p和w，g变红，使得黑高不变，而同时将g置为新的待调整节点</li><li>w为黑色的<ul><li>x为p的右孩子，之字形，p-x进行左旋，p变成待调整节点，将其调整成一字型</li><li>x为p的左孩子，一字型，g变红，p变黑，g-p进行右旋，调整结束</li></ul></li></ul><p>用来表示这三种转换操作如下<br>w为红色的情况<br><img src="https://i.imgur.com/lPIkMUF.png" alt=""><br>之字形情况<br><img src="https://i.imgur.com/LN7UQMf.png" alt=""><br>一字型情况<br><img src="https://i.imgur.com/gmwg6rv.png" alt=""><br>这样，根据我们的分析，我们可以很快写出调整代码，调整结束的条件是当前调整节点的父节点是黑色(当w为红色的时候上推的过程可能导致)，另外一个场景是一字型调整后父节点一定是黑色的了，所以也会跳出循环，不过我们在处理完后要将root的颜色置为黑色，因为在上推的过程中可能将根节点变为红色，而根节点的父节点nullNode是黑色的，所以虽然退出了循环，根节点却变成了黑色，所以我们要在最后改一下根节点的颜色，真个实现代码如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * x节点和其父节点红红冲突，进行调整</div><div class="line"> * <span class="doctag">@param</span> x</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insertBalance</span><span class="params">(RBNode&lt;T&gt; x)</span> </span>&#123;</div><div class="line"><span class="keyword">while</span>(x.parent.color==<span class="number">0</span>) &#123;<span class="comment">//在父节点为红色的情况下进行调整</span></div><div class="line">RBNode&lt;T&gt;p=x.parent;</div><div class="line"><span class="comment">//g一定不为null，因为root为黑色，nullNode也是黑色的，所以x必是三层及一下的</span></div><div class="line">RBNode&lt;T&gt;g=p.parent;</div><div class="line">RBNode&lt;T&gt;w;<span class="comment">//p的兄弟节点</span></div><div class="line"><span class="keyword">if</span>(p==g.left) &#123;<span class="comment">//p是左孩子</span></div><div class="line">w=g.right;</div><div class="line"><span class="keyword">if</span>(w.color==<span class="number">0</span>) &#123;<span class="comment">//p的兄弟节点为红色，仅需调整颜色即可</span></div><div class="line">w.color=<span class="number">1</span>;</div><div class="line">p.color=<span class="number">1</span>;</div><div class="line">g.color=<span class="number">0</span>;</div><div class="line">x=g;</div><div class="line"><span class="keyword">continue</span>;<span class="comment">//调整节点上推</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span> &#123;<span class="comment">//w的颜色为黑色</span></div><div class="line"><span class="keyword">if</span>(x==p.right) &#123;<span class="comment">//之字形双红，进行左旋</span></div><div class="line">rotateWithRightChild(p);</div><div class="line"><span class="comment">//更改相应的引用</span></div><div class="line">x=p;</div><div class="line">p=x.parent;<span class="comment">//g不变</span></div><div class="line">&#125;</div><div class="line"><span class="comment">//之字形调整后是一字型，一字型还是一字型，接下来都按一字型处理</span></div><div class="line">p.color=<span class="number">1</span>;<span class="comment">//先变色</span></div><div class="line">g.color=<span class="number">0</span>;</div><div class="line">rotateWithLeftChild(g);</div><div class="line">&#125;</div><div class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(p==g.right) &#123;<span class="comment">//p位于右边</span></div><div class="line">w=g.left;</div><div class="line"><span class="keyword">if</span>(w.color==<span class="number">0</span>) &#123;</div><div class="line">g.color=<span class="number">0</span>;</div><div class="line">w.color=<span class="number">1</span>;</div><div class="line">p.color=<span class="number">1</span>;</div><div class="line">x=g;</div><div class="line"><span class="keyword">continue</span>;</div><div class="line">&#125;<span class="keyword">else</span> &#123;</div><div class="line"><span class="keyword">if</span>(x==p.left) &#123;</div><div class="line">rotateWithLeftChild(p);</div><div class="line">x=p;</div><div class="line">p=x.parent;</div><div class="line">&#125;</div><div class="line">g.color=<span class="number">0</span>;</div><div class="line">p.color=<span class="number">1</span>;</div><div class="line">rotateWithRightChild(g);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//最后置root为黑色，w为红或黑都有可能结束循环</span></div><div class="line">root.color=<span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="红黑树的删除"><a href="#红黑树的删除" class="headerlink" title="红黑树的删除"></a>红黑树的删除</h2><p>说完了插入，这一节来将红黑树的删除，删除的逻辑和二叉查找树大同小异，第一步是找到删除节点，第二步判断删除节点的孩子情况，如果删除节点没有孩子节点，也就是左右孩子为nullNode，这里可以归结为左孩子为nullNode处理，删除当前节点，并用其右孩子代替其位置。对称的，右孩子为nullNode,则删除后用左孩子代替其位置。如果左右子树都不为nullNode,则将其换成其右子树的最小节点的值，转换成其右子树的最小节点，而这个节点一定没有左孩子，直接用其右孩子代替其位置即可。而剩下的问题就是根据删除节点的颜色来调整代替被删除节点的孩子节点。<br>如果删除的节点是红色，不需要进行调整。如果删除的节点是黑色节点，那么黑高收到了影响，如果代替它的孩子是红色，那么只需要将这个孩子变为黑色，黑高就得以恢复。而如果代替它的孩子是黑色，那么被删除的黑色无处填补，使得原来任意一个经过这个被删除节点的路径黑高减一，这种<strong>删除黑黑</strong>情况才是调整的重点，我们将这个调整过程叫做balanceDoubleBlack，在详细介绍之前，我们先写出删除的方法的详细。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(T x)</span> </span>&#123;</div><div class="line">RBNode&lt;T&gt;cur=root;</div><div class="line"><span class="comment">//查找待删除节点</span></div><div class="line"><span class="keyword">while</span>(cur!=nullNode &amp;&amp;cur.element.compareTo(x)!=<span class="number">0</span>) &#123;</div><div class="line"><span class="keyword">if</span>(x.compareTo(cur.element)&lt;<span class="number">0</span>)</div><div class="line">cur=cur.left;</div><div class="line"><span class="keyword">else</span></div><div class="line">cur=cur.right;</div><div class="line">&#125;</div><div class="line"></div><div class="line">RBNode&lt;T&gt;balanceNode;<span class="comment">//记录删除节点的孩子节点，也就是待调整节点</span></div><div class="line"><span class="keyword">int</span> deleteColor;</div><div class="line"><span class="keyword">if</span>(cur!=nullNode) &#123;</div><div class="line"><span class="keyword">if</span>(cur.left==nullNode) &#123;<span class="comment">//左子树为空和左右子树都为空一并处理</span></div><div class="line">balanceNode=cur.right;</div><div class="line">transplant(cur,cur.right);</div><div class="line">deleteColor=cur.color;</div><div class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(cur.right==nullNode)&#123;</div><div class="line">balanceNode=cur.left;</div><div class="line">transplant(cur,cur.left);</div><div class="line">deleteColor=cur.color;</div><div class="line">&#125;<span class="keyword">else</span> &#123;</div><div class="line">RBNode&lt;T&gt; minNode=findRightMin(cur);</div><div class="line">cur.element=minNode.element;</div><div class="line">deleteColor=minNode.color;</div><div class="line"><span class="comment">//这时候可以执行删除minNode，其必没有左孩子，可以直接用右孩子代替</span></div><div class="line">balanceNode=minNode.right;</div><div class="line">transplant(minNode,minNode.right);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//删除完毕，开始执行调整被删除节点的</span></div><div class="line"><span class="comment">//如果删除的是红色节点，则不影响，只考虑删除的是黑色节点</span></div><div class="line"><span class="keyword">if</span>(deleteColor==<span class="number">1</span>)</div><div class="line"><span class="keyword">if</span>(balanceNode.color==<span class="number">0</span>) &#123;</div><div class="line"><span class="comment">//balanceNode为红色，则删除的黑色补充到这个节点即可</span></div><div class="line">balanceNode.color=<span class="number">1</span>;</div><div class="line">&#125;<span class="keyword">else</span> &#123;</div><div class="line">balanceDoubleBlack(balanceNode);</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>根据上面所陈述的，在删除黑色节点后，补充上来的节点为balanceNode，如果其颜色也为黑色，那我们就可以认为balanceNode具有“双重”的黑色，需要使用某些方法来“消解”它这个过火的黑色，如何消解呢？方法是从balanceNode和其兄弟节点w上各取一层黑色上推给其父节点p，如果p是红色节点，直接将其变成黑色就完成了调整，否则的话其父节点p就变成了新的“双黑节点”，需要进一步调整。<br>但是从兄弟节点提一层黑色要兄弟节点是黑色节点才行，如果其兄弟节点是红色节点，那么就需要变色+旋转将其兄弟节点w的颜色变成黑色，交给其兄弟节点是黑色的情况进行处理。<br>如果其兄弟节点是黑色，那么我们是不是可以放心的提色了？也不是的，只有兄弟节点的左右子孩子都是黑色我们才可以提色，因为如果不是这样，我们提过色之后就会造成红红冲突。那么如果balanceNode的兄弟节点w有孩子是红色的，有什么情况是我们比较容易处理的，或者这样问,有没有方法可以调整成功？答案是有的，计算机大佬们已经找到了这种情况，假设balanceNode为p的左孩子，w为p的右孩子的情况下，w的右孩子如果为红色（p,w,wchild成一字型），我们就可以通过变色+旋转的方法一次调整成功。而如果其右孩子是黑色，左孩子为红色（p,w,w-red成之字形），我们可以通过变色+旋转的方法将其变成一字型的情况进一步处理。<br>总的来说，我们将其分为一下四种情况（balanceNode为双重黑色节点，p为balanceNode的父节点，balance为p的左孩子，w为p的右孩子，w1为w的左孩子，w2为w的右孩子）</p><ol><li>w为红色，将p变成红色，将w变为黑色，p-w左旋转</li><li>w为黑色<br> 2.1 w的左右孩子都为黑色，将w变红色，p变为新的双重颜色节点(黑红或黑黑)<br> 2.2 w的左孩子w1为红色，右孩子w2为黑色，将w1变黑色，w变红色，w-w2右旋转，转到下面一种<br> 2.3 w的右孩子w2为红色，w变成p的颜色（可能为红，也可能为黑），p变成黑色，w2变成黑色，p-w左旋</li></ol><p>整个算法结束的出口是balanceNode为红色，或者balanceNode已经是根了<br>用图来描述的话也就如下(不确定颜色用蓝色表示)<br>w为红色，将p变成红色，将w变为黑色，p-w左旋转<br><img src="https://i.imgur.com/ZGYwAZH.png" alt=""><br>w为黑色，并且左右子树都为黑色，将w变红色，p变为新的双重颜色节点(黑红或黑黑)<br><img src="https://i.imgur.com/qfm5V7N.png" alt=""><br>w为黑色，w的左孩子w1为红色，右孩子w2为黑色，将w1变黑色，w变红色，w-w2右旋转，转到2.3的情况<br><img src="https://i.imgur.com/zu2fd0G.png" alt=""><br>w为黑色，w的右孩子w2为红色，w变成p的颜色（可能为红，也可能为黑），p变成黑色，w2变成黑色，p-w左旋，调整结束<br><img src="https://i.imgur.com/Wd97UXu.png" alt=""></p><p>根据上面的分析，我们有如下实现代码,算法出口为balanceNode为root或者balanceNode为红色，也就是在balanceNode不为root并且balanceNode为黑色的时候进行循环调整<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * balanceNode为双重黑色，进行调整</div><div class="line"> * <span class="doctag">@param</span> balanceNode</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">balanceDoubleBlack</span><span class="params">(RBNode&lt;T&gt; balanceNode)</span> </span>&#123;</div><div class="line"><span class="comment">//在balanceNode不为根节点，并且颜色为黑的情况下进行调整</span></div><div class="line"><span class="keyword">while</span>(balanceNode!=root&amp;&amp; balanceNode.color==<span class="number">1</span>) &#123;</div><div class="line">RBNode&lt;T&gt; p=balanceNode.parent;</div><div class="line">RBNode&lt;T&gt; w;</div><div class="line"><span class="keyword">if</span>(p.left==balanceNode) &#123;</div><div class="line"><span class="comment">//balanceNode为其父节点的左孩子</span></div><div class="line"><span class="comment">//按balanceNode的兄弟节点的颜色分两大类</span></div><div class="line">w=p.right;</div><div class="line"><span class="keyword">if</span>(w.color==<span class="number">0</span>) &#123;</div><div class="line"><span class="comment">//兄弟节点为红色</span></div><div class="line">w.color=<span class="number">1</span>;</div><div class="line">p.color=<span class="number">0</span>;</div><div class="line">rotateWithRightChild(p);</div><div class="line">w=p.right;<span class="comment">//w变了</span></div><div class="line">&#125;<span class="keyword">else</span> &#123;</div><div class="line"><span class="comment">//兄弟节点为黑色</span></div><div class="line"><span class="comment">//当兄弟节点的颜色为黑色的时候分为3种情况</span></div><div class="line"><span class="comment">//1. 兄弟节点左右子还是都是黑色节点，则从两边各提一层黑</span></div><div class="line"><span class="keyword">if</span>(w.left.color==<span class="number">1</span>&amp;&amp;w.right.color==<span class="number">1</span>) &#123;</div><div class="line">w.color=<span class="number">0</span>;</div><div class="line">balanceNode=p;</div><div class="line">&#125;<span class="keyword">else</span> &#123;</div><div class="line"><span class="comment">//2. 兄弟节点的左孩子为红色，右还是为黑色，w与w-leftchild,p构成之字形</span></div><div class="line"><span class="comment">//在不改变黑高的情况下调整成一字型</span></div><div class="line"><span class="keyword">if</span>(w.left.color==<span class="number">0</span>&amp;&amp;w.right.color==<span class="number">1</span>) &#123;</div><div class="line">w.color=<span class="number">0</span>;</div><div class="line">w.left.color=<span class="number">1</span>;</div><div class="line">rotateWithLeftChild(w);</div><div class="line">w=p.right;</div><div class="line">&#125;</div><div class="line"><span class="comment">//3. 兄弟节点的右孩子为红色，p,w与w.right一字型，</span></div><div class="line"><span class="comment">//w变成p的颜色，p变成黑色，w.right变成黑色，左旋</span></div><div class="line">w.color=p.color;</div><div class="line">p.color=<span class="number">1</span>;</div><div class="line">w.right.color=<span class="number">1</span>;</div><div class="line">rotateWithRightChild(p);</div><div class="line"><span class="comment">//调整结束,最后将根节点调为黑色</span></div><div class="line">balanceNode=root;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;<span class="keyword">else</span> &#123;</div><div class="line"><span class="comment">//balanceNode为其父节点的右孩子</span></div><div class="line">w=p.left;</div><div class="line"><span class="keyword">if</span>(w.color==<span class="number">0</span>) &#123;</div><div class="line"><span class="comment">//兄弟节点为红色</span></div><div class="line">p.color=<span class="number">0</span>;</div><div class="line">w.color=<span class="number">1</span>;</div><div class="line">rotateWithLeftChild(p);</div><div class="line">w=p.left;</div><div class="line">&#125;<span class="keyword">else</span> &#123;</div><div class="line"><span class="comment">//兄弟节点为黑色</span></div><div class="line"><span class="keyword">if</span>(w.left.color==<span class="number">1</span>&amp;&amp; w.right.color==<span class="number">1</span>) &#123;</div><div class="line">w.color=<span class="number">0</span>;</div><div class="line">balanceNode=p;</div><div class="line">&#125;<span class="keyword">else</span> &#123;</div><div class="line"><span class="keyword">if</span>(w.left.color==<span class="number">1</span>&amp;&amp; w.right.color==<span class="number">0</span>) &#123;</div><div class="line">w.right.color=<span class="number">1</span>;</div><div class="line">w.color=<span class="number">0</span>;</div><div class="line">rotateWithRightChild(w);</div><div class="line">w=p.left;</div><div class="line">&#125;</div><div class="line">w.color=p.color;</div><div class="line">p.color=<span class="number">1</span>;</div><div class="line">w.left.color=<span class="number">1</span>;</div><div class="line">rotateWithLeftChild(p);</div><div class="line">balanceNode=root;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">balanceNode.color=<span class="number">1</span>;<span class="comment">//防止最后的调整好的根节点为红色</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="nullNode的作用之处"><a href="#nullNode的作用之处" class="headerlink" title="nullNode的作用之处"></a>nullNode的作用之处</h2><p>nullNode在简化我们编程的过程中起到了很重要的作用，这使得我们避免NullpointException的情况，它的作用和链表中的头节点一样，其唯一的目的是简化我们的操作，但是我们还是不能避免对是nullNode的情况下进行特殊处理，那么在整个红黑树的过程中，我们都是在哪里需要nullNode的情况的呢，总结如下：</p><ol><li>旋转的时候判断祖父节点g是否为nullNode，如果是的话旋转后就换新根</li><li>用一个节点代替另一个节点的时候，如果被代替节点的父节点为空的话（被代替节点为根节点），则需要将新节点置为根</li><li>插入的时候，如果插入节点的父节点为nullNode的话，直接置插入节点为根节点</li><li>删除时候的判空操作</li></ol><h2 id="关于源码"><a href="#关于源码" class="headerlink" title="关于源码"></a>关于源码</h2><p>本文所有源码可以从<a href="https://github.com/buwenqi/DataStructure/tree/master/src/rbtree" target="_blank" rel="external">这里</a>获得，本文首发表于<a href="https://buwenqi.github.io" target="_blank" rel="external">我的博客</a>,欢迎关注！转载须注明文章出处，作者保留文章所有权。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>算法导论</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;红黑树(RBTree)是一种相比平衡二叉树(AVL)平衡要求较低的的一种二叉搜索树，所谓平衡要求较低的意思是相比AVL树的每个节点的左右子树的高度差不能超过2，红黑树使用红黑两种颜色来标记二叉搜索树中的节点，并对这种着色进行限制，使得在插入删除操作后对不符合的情况必须进行调整来保持这样一种限制，从而实现自我平衡。我们先来看一下红黑树的定义，也就是着色限制&lt;br&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis之关联映射解析</title>
    <link href="http://yoursite.com/2017/12/30/MyBatis%E4%B9%8B%E5%85%B3%E8%81%94%E6%98%A0%E5%B0%84%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2017/12/30/MyBatis之关联映射解析/</id>
    <published>2017-12-30T08:49:51.000Z</published>
    <updated>2018-02-21T14:26:34.722Z</updated>
    
    <content type="html"><![CDATA[<p>ORM框架一个重要的技术点是处理对象间的关联映射，比如一对一，一对多的关系，和Hibernate不同的是，Mybatis的使用需要开发人员直接和SQL语句进行打交道，所以在处理关联映射的时候不论是文件配置还是实现原理都是大有不同的，本文致力于使用一个例子讲清楚不同关联映射关系的配置和使用方法，以及作者在使用过程中对不同的参数的作用的深入理解。<br><a id="more"></a></p><h2 id="对象关系"><a href="#对象关系" class="headerlink" title="对象关系"></a>对象关系</h2><p>我们有这样的一组对象关系，简单来说，一个雇员(Employee)有一个工卡(WorkCard),有多个员工任务（EmployeeTask），员工任务仅包含一个任务（Task）,对于员工来还有体检表(HealthForm)，但是由于有体检的内容男女有别，所以我们从Employee继承出来FemaleEmployee和MaleEmpolyee,分别包含FemaleHealthForm和MaleHealthForm。<br><img src="https://i.imgur.com/gszEuvi.png" alt=""><br>从表的结构来看，其关键的外键关系如下<br><img src="https://i.imgur.com/GrH3gJy.png" alt=""></p><h2 id="Mybatis配置"><a href="#Mybatis配置" class="headerlink" title="Mybatis配置"></a>Mybatis配置</h2><p>我们从简单的EmployeeTask和Task之间的一对一关系来说，无论是从Java Bean的角度来看还是从表的关系来看，都是EmployeeTask在维护关联关系。我们所说的关联关系的使用更多的是在查询的时候，也就是在查询的时候能够以级联的查询出关联的对象。对于插入的时候，因为Mybatis的实现原理是开发人员自定义SQL语句，所以不能实现级联的插入，我们只需要提供一个关联对象相关联的外键，就像在插入EmployeeTask的时候如何处理Task对象这个属性这样（点击<a href="https://github.com/buwenqi/SSM/blob/master/src/main/java/multiAssociation/pojo/EmployeeTaskMapper.xml" target="_blank" rel="external">这里</a>）<br><img src="https://i.imgur.com/0Aao0dx.png" alt=""></p><h3 id="一对一查询"><a href="#一对一查询" class="headerlink" title="一对一查询"></a>一对一查询</h3><p>所以我们接下来更加着重考虑在查询操作(select)的时候的级联映射的配置,也就是对select后的resultMap如何配置（resultMap是描述从数据库中查询出的数据列和pojo的属性之间如何映射，如果列名和属性名一致的可以不用配置，会进行自动映射）。 拿EmployeeTask来说，对于其查询语句我们有<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getEmployeeTaskByEmpId"</span> <span class="attr">parameterType</span>=<span class="string">"long"</span> <span class="attr">resultMap</span>=<span class="string">"empTaskResultMap"</span>&gt;</span></div><div class="line">       select * from t_employee_task where emp_id=#&#123;empId&#125;</div><div class="line">   <span class="tag">&lt;/<span class="name">select</span>&gt;</span></div></pre></td></tr></table></figure></p><p>其中empTaskResultMap的配置如下<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"empTaskResultMap"</span> <span class="attr">type</span>=<span class="string">"multiAssociation.pojo.EmployeeTask"</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">property</span>=<span class="string">"id"</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"emp_id"</span> <span class="attr">property</span>=<span class="string">"empId"</span>/&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"task_name"</span> <span class="attr">property</span>=<span class="string">"taskName"</span>/&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">association</span> <span class="attr">column</span>=<span class="string">"task_id"</span> <span class="attr">property</span>=<span class="string">"task"</span> <span class="attr">select</span>=<span class="string">"multiAssociation.pojo.TaskMapper.getTaskById"</span>/&gt;</span></div><div class="line">     <span class="comment">&lt;!-- select语句对应的是对应mapper xml中方法的id--&gt;</span></div><div class="line"> <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></div></pre></td></tr></table></figure></p><p>这里面我们对列名和属性名不一致的情况进行了配置，并且使用到了association标签，这个标签是用来关联一个对象的，解读一下这个语句的意思就是：将列task_id的值左为参数传入multiAssociation.pojo.TaskMapper.getTaskById作为参数查询后作为task属性的值，其中multiAssociation.pojo.TaskMapper.getTaskById是TaskMapper配置文件中指定的查询语句，这种方式称为嵌套查询，所以TaskMapper中必须有对应的方法才可以，也就是下面的配置<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getTaskById"</span> <span class="attr">parameterType</span>=<span class="string">"long"</span> <span class="attr">resultType</span>=<span class="string">"multiAssociation.pojo.Task"</span>&gt;</span></div><div class="line">     select * from t_task where id=#&#123;id&#125;</div><div class="line"> <span class="tag">&lt;/<span class="name">select</span>&gt;</span></div></pre></td></tr></table></figure></p><p>当然我们也可以通过另一种方式，就是在getEmployeeTaskByEmpId的select语句中使用连接查询，然后将对应的task列对应的值映射到对应的属性上也是可以的</p><h3 id="一对多映射"><a href="#一对多映射" class="headerlink" title="一对多映射"></a>一对多映射</h3><p>一对多映射使用collection标签，它的使用方法和association是一样的，我们使用Employee来做为示例，它有一个一对一关系和一个一对多的关系，它的resultMap配置如下<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"employeeResultMap"</span> <span class="attr">type</span>=<span class="string">"multiAssociation.pojo.Employee"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">property</span>=<span class="string">"id"</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"real_name"</span> <span class="attr">property</span>=<span class="string">"realName"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"sex"</span> <span class="attr">property</span>=<span class="string">"sex"</span> <span class="attr">typeHandler</span>=<span class="string">"org.apache.ibatis.type.EnumOrdinalTypeHandler"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"POSITION"</span> <span class="attr">property</span>=<span class="string">"position"</span>/&gt;</span></div><div class="line"></div><div class="line">        <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">"workCard"</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">select</span>=<span class="string">"multiAssociation.pojo.WorkCardMapper.getWorkCardByEmpId"</span>/&gt;</span></div><div class="line"></div><div class="line">        <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">"employeeTaskList"</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">select</span>=<span class="string">"multiAssociation.pojo.EmployeeTaskMapper.getEmployeeTaskByEmpId"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">discriminator</span> <span class="attr">javaType</span>=<span class="string">"long"</span> <span class="attr">column</span>=<span class="string">"sex"</span>&gt;</span></div><div class="line">            <span class="comment">&lt;!--最后返回的resultMap会取代原来的resultMap,所以后面的的resultMap要extends--&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">case</span> <span class="attr">value</span>=<span class="string">"0"</span> <span class="attr">resultMap</span>=<span class="string">"femaleEmployeeResultMap"</span>&gt;</span><span class="tag">&lt;/<span class="name">case</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">case</span> <span class="attr">value</span>=<span class="string">"1"</span> <span class="attr">resultMap</span>=<span class="string">"maleEmployeeFormResultMap"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">discriminator</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></div></pre></td></tr></table></figure></p><p>可以看到association标签和collection标签的使用几乎一模一样，那么它们对于select标签使用的嵌套方法有没有什么特殊的要求，答案是没有的，这里嵌套的select依赖于对应的Mapper的xml文件配置的，而不依赖于具有明确返回类型（单个对象或者对象列表）Mapper接口方法，从这个角度来说，xml配置问题不是强依赖于接口的。直观的来说multiAssociation.pojo.EmployeeTaskMapper.getEmployeeTaskByEmpId虽然是配置到collection的嵌套查询中，但是在对应的Mapper接口中其返回值可能仅仅是一个对象。<br>另外大家可能注意到了discriminator标签，这段配置的意思根据查询结果的sex列的值，如果sex为0，则返回femaleEmployeeResultMap作为最终结果，如果是1，则返回maleEmployeeFormResultMap作为结果，当然，我们也需要femaleEmployeeResultMap和maleEmployeeFormResultMap继承上面employeeResultMap的基础属性，这个使用extends来实现，从而实现了有判别的返回类对象。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"femaleEmployeeResultMap"</span> <span class="attr">type</span>=<span class="string">"multiAssociation.pojo.FemaleEmployee"</span> <span class="attr">extends</span>=<span class="string">"employeeResultMap"</span>&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">"femaleHealthForm"</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">select</span>=<span class="string">"multiAssociation.pojo.FemaleHealthFormMapper.getFemaleHealthFormWithEmpId"</span>/&gt;</span></div><div class="line">   <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></div><div class="line"></div><div class="line">   <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"maleEmployeeFormResultMap"</span> <span class="attr">type</span>=<span class="string">"multiAssociation.pojo.MaleEmployee"</span> <span class="attr">extends</span>=<span class="string">"employeeResultMap"</span>&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">"maleHealthForm"</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">select</span>=<span class="string">"multiAssociation.pojo.MaleHealthFormMapper.getMaleHealthFormWithEmpId"</span>/&gt;</span></div><div class="line">   <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></div></pre></td></tr></table></figure></p><h2 id="关于源码"><a href="#关于源码" class="headerlink" title="关于源码"></a>关于源码</h2><p>你可以在<a href="https://github.com/buwenqi/SSM/tree/master/src/main/java/multiAssociation" target="_blank" rel="external">这里</a>找到本文的所有源码，本文发表于<a href="https://buwenqi.github.io" target="_blank" rel="external">我的博客</a>，欢迎关注!</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="http://www.mybatis.org/mybatis-3/zh/sqlmap-xml.html#Result_Maps" target="_blank" rel="external">Mapper-XML文件 Result_Maps</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ORM框架一个重要的技术点是处理对象间的关联映射，比如一对一，一对多的关系，和Hibernate不同的是，Mybatis的使用需要开发人员直接和SQL语句进行打交道，所以在处理关联映射的时候不论是文件配置还是实现原理都是大有不同的，本文致力于使用一个例子讲清楚不同关联映射关系的配置和使用方法，以及作者在使用过程中对不同的参数的作用的深入理解。&lt;br&gt;
    
    </summary>
    
    
      <category term="ssm" scheme="http://yoursite.com/tags/ssm/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis之TypeHandler解析</title>
    <link href="http://yoursite.com/2017/12/17/MyBatis%E4%B9%8BTypeHandler%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2017/12/17/MyBatis之TypeHandler解析/</id>
    <published>2017-12-17T11:15:48.000Z</published>
    <updated>2018-02-21T14:26:34.721Z</updated>
    
    <content type="html"><![CDATA[<p>MyBatis作为一个ORM框架，在实现对象到关系数据库映射的过程中，一个无法避免的问题就是Java类型和JDBC类型之间的相互转换，而TypeHandler的作用就在于此，其作用是实现Java类型向JDBC类型之间的转换。<br><a id="more"></a><br>从上面的描述上来看，TypeHandler的作用对象是一个对象属性，从Java类型向JDBC类型之间的转换这样的说法或许过于抽象，举个例子来说，比如我们有个对象的属性是String数组，我想在插入数据库的时候将这个属性在插入数据库的时候是以一个varchar的属性记录，数组中每个元素以逗号相隔，这是从Java类型转换到JDBC；而从数据库获取这个对象的属性的时候又能够分割开逗号返回对象String数组，这是从JDBC转换到Java类型。<br>从实现层次上来说TypeHandler的功能，就是在我们使用MyBatis插入一个对象数据的时候，对象的每条属性是在经过如何处理后放入JDBC的SQL语句中，在取出一条数据库记录的时候，每一列的数据又是经过如何的处理放入对象的属性中的，这两个方面我们完全可以从MyBatis提供<code>TypeHandler</code>类中得以体现。</p><p><code>org.apache.ibatis.type.TypeHandler</code>是所有TypeHandler的基类，里面有四个方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">setParameter</span><span class="params">(PreparedStatement var1, <span class="keyword">int</span> var2, T var3, JdbcType var4)</span> <span class="keyword">throws</span> SQLException</span>;</div><div class="line"></div><div class="line">   <span class="function">T <span class="title">getResult</span><span class="params">(ResultSet var1, String var2)</span> <span class="keyword">throws</span> SQLException</span>;</div><div class="line"></div><div class="line">   <span class="function">T <span class="title">getResult</span><span class="params">(ResultSet var1, <span class="keyword">int</span> var2)</span> <span class="keyword">throws</span> SQLException</span>;</div><div class="line"></div><div class="line">   <span class="function">T <span class="title">getResult</span><span class="params">(CallableStatement var1, <span class="keyword">int</span> var2)</span> <span class="keyword">throws</span> SQLException</span>;</div></pre></td></tr></table></figure></p><p>其中setParameter是将一个对象的属性经过转换后插入到PreparedStatement,后面三个方法是将从ResultSet中取出的值处理后返回给对象的属性(分别是通过列名，列索引来获取值，最后一个适用于存储过程)。而<code>org.apache.ibatis.type.BaseTypeHandler</code>则实现了TypeHandler，做了一些null值上的处理，一般情况下我们自定义的类型处理器直接继承自BaseTypeHandler,并覆盖一下四个方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">setNonNullParameter</span><span class="params">(PreparedStatement var1, <span class="keyword">int</span> var2, T var3, JdbcType var4)</span> <span class="keyword">throws</span> SQLException</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> T <span class="title">getNullableResult</span><span class="params">(ResultSet var1, String var2)</span> <span class="keyword">throws</span> SQLException</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> T <span class="title">getNullableResult</span><span class="params">(ResultSet var1, <span class="keyword">int</span> var2)</span> <span class="keyword">throws</span> SQLException</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> T <span class="title">getNullableResult</span><span class="params">(CallableStatement var1, <span class="keyword">int</span> var2)</span> <span class="keyword">throws</span> SQLException</span>;</div></pre></td></tr></table></figure></p><p>对于一下简单的TypeHandler MyBatis已经默认提供了，对于一些比较难处理的，比如数组，容器，自定义简单对象需要我们自己自定义TypeHandler进行类型处理。</p><h2 id="自定义StringArrayTypeHandler"><a href="#自定义StringArrayTypeHandler" class="headerlink" title="自定义StringArrayTypeHandler"></a>自定义StringArrayTypeHandler</h2><p><img src="https://i.imgur.com/lQo7h7S.png" alt=""><br>上图显示了在构建MyBatis程序的一般过程，其中橙色的线是我们在使用TypeHandler的过程中的一些重要步骤，我在图中做了数字标注。</p><h3 id="编写StringArrayTypeHandler"><a href="#编写StringArrayTypeHandler" class="headerlink" title="编写StringArrayTypeHandler"></a>编写StringArrayTypeHandler</h3><p>首先第一步是编写属性的类型转换器，我们这里用编写的String数组的类型转换器作为例子。假设JavaBean是Student有如下属性<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</div><div class="line">    <span class="keyword">private</span> SexEnum sex;</div><div class="line">    <span class="keyword">private</span> String[] interests;</div><div class="line"><span class="comment">//getter and setter</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>其中interests属性是一个数组，我们第一步编写StringArrayTypeHandler，它继承自BaseTypeHandler<string[]>,其前两个方法如下，它将String数组用逗号串联起来放入了PreparedStatement,又将从数据库中的值split后放入了String数组，从而实现了类型转换。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 将java类型转换为JDBC类型</div><div class="line">   */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNonNullParameter</span><span class="params">(PreparedStatement preparedStatement, <span class="keyword">int</span> i, String[] strings, JdbcType jdbcType)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">      StringBuilder builder=<span class="keyword">new</span> StringBuilder();</div><div class="line">      <span class="keyword">for</span>(String item: strings)&#123;</div><div class="line">          builder.append(item+<span class="string">","</span>);</div><div class="line">      &#125;</div><div class="line">      builder.deleteCharAt(builder.length()-<span class="number">1</span>);</div><div class="line">      System.out.println(builder.toString());</div><div class="line">      preparedStatement.setString(i,builder.toString());</div><div class="line"></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="comment">/**</span></div><div class="line">   *通过列名获取Java类型的值</div><div class="line">   */</div><div class="line">  <span class="keyword">public</span> String[] getNullableResult(ResultSet resultSet, String s) <span class="keyword">throws</span> SQLException &#123;</div><div class="line">      String result=resultSet.getString(s);</div><div class="line">      <span class="keyword">if</span>(result!=<span class="keyword">null</span>)&#123;</div><div class="line">          <span class="keyword">return</span> result.split(<span class="string">","</span>);</div><div class="line">      &#125;<span class="keyword">else</span>&#123;</div><div class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">      &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></string[]></p><h3 id="编写Mapper接口"><a href="#编写Mapper接口" class="headerlink" title="编写Mapper接口"></a>编写Mapper接口</h3><p>第二步是先写业务需求的接口，我们这里定义了插入和查找两个接口<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StudentMapper</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">insertStudent</span><span class="params">(Student student)</span></span>;</div><div class="line">    <span class="function">Student <span class="title">findStudentById</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="配置Mapper文件"><a href="#配置Mapper文件" class="headerlink" title="配置Mapper文件"></a>配置Mapper文件</h3><p>定义完业务接口就可以配置Mapper文件，这个是我们使用TypeHandler的地方，有两处使用到了我们定义的StringArrayTypeHandler,第一处是在我们插入值的参数处,使用了typeHandler参数。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"insertStudent"</span> <span class="attr">parameterType</span>=<span class="string">"TypeHandler.Student"</span> <span class="attr">useGeneratedKeys</span>=<span class="string">"true"</span> <span class="attr">keyProperty</span>=<span class="string">"id"</span>&gt;</span></div><div class="line">       insert into student(stu_name,stu_age,stu_interests,stu_sex) values(#&#123;name&#125;,#&#123;age&#125;,</div><div class="line">       #&#123;interests,typeHandler=TypeHandler.StringArrayTypeHandler&#125;,</div><div class="line">       #&#123;sex,typeHandler=org.apache.ibatis.type.EnumOrdinalTypeHandler&#125;)</div><div class="line">   <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></div></pre></td></tr></table></figure></p><p>另一处是在select的resultMap中<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"stuResult"</span> <span class="attr">type</span>=<span class="string">"TypeHandler.Student"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"stu_id"</span> <span class="attr">property</span>=<span class="string">"id"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"stu_name"</span> <span class="attr">property</span>=<span class="string">"name"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"stu_age"</span> <span class="attr">property</span>=<span class="string">"age"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"stu_sex"</span> <span class="attr">property</span>=<span class="string">"sex"</span> <span class="attr">typeHandler</span>=<span class="string">"org.apache.ibatis.type.EnumOrdinalTypeHandler"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"stu_interests"</span> <span class="attr">property</span>=<span class="string">"interests"</span> <span class="attr">typeHandler</span>=<span class="string">"TypeHandler.StringArrayTypeHandler"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></div></pre></td></tr></table></figure></p><p>这两个方法Mapper方法的调用会引起我们自定义的StringArrayTypeHandler的setNonNullParameter和getNullableResult方法的调用。<br>Mapper配置文件和Mapper接口直接的管理是Mapper配置文件来维护的，Mapper配置文件namespace指定了Mapper接口的全称限名，并且对应的select，insert子标签的id对应于Mapper接口的方法名。</p><h3 id="基础配置文件加载Mapper文件"><a href="#基础配置文件加载Mapper文件" class="headerlink" title="基础配置文件加载Mapper文件"></a>基础配置文件加载Mapper文件</h3><p>第四步就是在MyBatis的基础配置文件中加载Mapper配置文件<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">"TypeHandler/StudentMapper.xml"</span>/&gt;</span></div></pre></td></tr></table></figure></p><p>如果是非显示使用TypeHandler还要在基础配置文件中注册TypeHandler，显示使用则不用。显示使用是指直接指定TypeHandler的全称限名，非显示使用只指定type和jdbcType,让框架去寻找合适的TypeHandler</p><h3 id="使用Mapper接口进行测试"><a href="#使用Mapper接口进行测试" class="headerlink" title="使用Mapper接口进行测试"></a>使用Mapper接口进行测试</h3><p>这一阶段需要经过加载基础配置文件，获取SqlSessionFactory，打开SqlSession，getMapper执行sql语句的过程，至此整个过程结束，程序顺利运行<br><img src="https://i.imgur.com/0UF2Dcs.png" alt=""></p><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><ul><li>没有声明别名的类一定要写成全称限名</li><li>主键回填不仅要设置useGeneratedKeys=true,还要设置keyProperty</li></ul><h2 id="EnumOrdinalTypeHandler和EnumTypeHandler"><a href="#EnumOrdinalTypeHandler和EnumTypeHandler" class="headerlink" title="EnumOrdinalTypeHandler和EnumTypeHandler"></a>EnumOrdinalTypeHandler和EnumTypeHandler</h2><p>这两个都是MyBatis内置的处理Enum类型属性的类型转换器，其区别在于在存入数据库的时候EnumOrdinalTypeHandler是调用ordinal()方法获取索引存储，而EnumTypeHandler是调用name()方法获取名称进行存储，取回的时候也是同样策略的逆过程，比如我们上面使用了EnumOrdinalTypeHandler，其对应的枚举类型如下，而数据库存储的stu_sex为对应的索引0或1<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> SexEnum &#123;</div><div class="line">    FEMALE(<span class="string">"女"</span>),MALE(<span class="string">"男"</span>);</div><div class="line">    <span class="keyword">private</span> String sexName;</div><div class="line">    SexEnum(String sexName)&#123;</div><div class="line">        <span class="keyword">this</span>.sexName=sexName;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSexName</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> sexName;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSexName</span><span class="params">(String sexName)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.sexName = sexName;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="关于源码"><a href="#关于源码" class="headerlink" title="关于源码"></a>关于源码</h2><p>你可以在<a href="https://github.com/buwenqi/SSM/tree/master/src/main/java/TypeHandler" target="_blank" rel="external">这里</a>找到本文的全部源码，你同样可以在<a href="https://buwenqi.github.io/" target="_blank" rel="external">我的博客</a>看到这篇文章。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;MyBatis作为一个ORM框架，在实现对象到关系数据库映射的过程中，一个无法避免的问题就是Java类型和JDBC类型之间的相互转换，而TypeHandler的作用就在于此，其作用是实现Java类型向JDBC类型之间的转换。&lt;br&gt;
    
    </summary>
    
    
      <category term="ssm" scheme="http://yoursite.com/tags/ssm/"/>
    
  </entry>
  
  <entry>
    <title>idea使用maven构建mybatis程序遇到的几个问题</title>
    <link href="http://yoursite.com/2017/12/06/idea%E4%BD%BF%E7%94%A8maven%E6%9E%84%E5%BB%BAmybatis%E7%A8%8B%E5%BA%8F%E9%81%87%E5%88%B0%E7%9A%84%E5%87%A0%E4%B8%AA%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2017/12/06/idea使用maven构建mybatis程序遇到的几个问题/</id>
    <published>2017-12-06T03:42:29.000Z</published>
    <updated>2018-02-21T14:26:34.726Z</updated>
    
    <content type="html"><![CDATA[<p>最近在学习Mabatis的使用，在使用idea maven构建mabatis程序的时候遇到了以往在非maven构建的问题，总结如下，以备后查。<br><a id="more"></a></p><h2 id="变更的MySQL-JDBC-6-0驱动类名"><a href="#变更的MySQL-JDBC-6-0驱动类名" class="headerlink" title="变更的MySQL JDBC 6.0驱动类名"></a>变更的MySQL JDBC 6.0驱动类名</h2><p>MYSQL JDBC6.0+版本的驱动类全称限名改为了com.mysql.cj.jdbc.Driver，相比原来的名字，多了一个cj，并且需要在url中指明时区，否则会报错，例如<code>url=jdbc:mysql://localhost:3306/test?serverTimezone=UTC</code></p><h2 id="使用maven构建导致未找到配置文件"><a href="#使用maven构建导致未找到配置文件" class="headerlink" title="使用maven构建导致未找到配置文件"></a>使用maven构建导致未找到配置文件</h2><p>我们构建普通的Java项目的时候需要的外部资源文件（比如一个txt文件）的起始目录是项目的根目录，而maven构建的项目却不同，以quickstart模板为例，其自动生成的源代码存放目录是src/main/java/selfPackagePath/xxx.java,而编译后所有的的class类会存放到target/classes/selfPackagePath/xxx.class,不包含任何非class文件，并且其中类的<strong>所用的当前位置</strong>是target/classes,也就是说，在原来src中存放的xml等其他配置文件并没有在编译后的包里，这会导致奇怪的文件找不到IOException。类所使用的当前路径可以通过<code>Class.class.getClass().getResource(&quot;/&quot;).getPath()</code>查看。<br>解决的方法是在pom文件中添加例如下面一段配置信息<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">resources</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">resource</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/config<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">includes</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">resource</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">includes</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></div></pre></td></tr></table></figure></p><p>其作用是加载src/config中的以xml和properties为结尾资源文件到target/classes目录，加载src/main/java中的xml文件到target/classes,注意，加载的文件都是加载到以target/classes为起始的目录，如果加载的文件处于另一个子目录下，比如src/main/java/wenqi/xxx.xml，应用上面的配置，这个文件会被加载早target/classes/wenqi/xxx.xml，有点对齐头，加尾的意思。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在学习Mabatis的使用，在使用idea maven构建mabatis程序的时候遇到了以往在非maven构建的问题，总结如下，以备后查。&lt;br&gt;
    
    </summary>
    
    
      <category term="ssm" scheme="http://yoursite.com/tags/ssm/"/>
    
  </entry>
  
  <entry>
    <title>Java NIO解析</title>
    <link href="http://yoursite.com/2017/12/02/Java%20NIO%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2017/12/02/Java NIO解析/</id>
    <published>2017-12-02T02:14:01.000Z</published>
    <updated>2018-02-21T14:26:34.718Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章先从阻塞与非阻塞，同步与异步之间的定义和关系说起，然后探讨liunx下的5种IO模型，支持非阻塞IO的select/poll/epoll系统调用的基本原理，然后通过Java代码搭建bio方式的服务端，改进服务器在并发场景下bio多线程和线程池的实现方式，最后介绍Java nio来实现一个服务器和多个客户端对话。<br><a id="more"></a></p><h2 id="阻塞与非阻塞，同步与异步"><a href="#阻塞与非阻塞，同步与异步" class="headerlink" title="阻塞与非阻塞，同步与异步"></a>阻塞与非阻塞，同步与异步</h2><p>如果从程序调用来讲，阻塞是指我们执行一个函数调用不能立即得到返回值，而依赖于其他外部的事件完成，比如说网络包的到达、IO操作的完成，否则的话就是非阻塞。其根本原因是cpu执行指令的速度远大于网络操作、IO操作的速度，这种速度差导致了程序运行的阻塞。<br>同步与异步是从另一个角度来看程序的运行，它是指在程序运行的过程中遇到阻塞事件是否能够让出cpu去处理其他的事情，如果能的话，就是异步的，如果不能的话就是同步的。<br>从这个角度来看，阻塞与非阻塞，同步与异步是一个事情的两个方面，以IO为对象来说，阻塞IO必然导致着同步，而非阻塞IO也必然导致着异步。</p><h2 id="liunx的5种网络IO模型"><a href="#liunx的5种网络IO模型" class="headerlink" title="liunx的5种网络IO模型"></a>liunx的5种网络IO模型</h2><p><img src="https://i.imgur.com/Ty01EyQ.jpg" alt=""><br>上图显示了liunx的5种IO模型，其中包括了读的两个执行过程：阶段1）从IO设备读取数据到内核空间(wait for data)和 阶段2）从内核空间复制数据到用户空间(copy data from kernel to user)</p><ul><li>阻塞IO,不论是阶段1还是阶段2都是处于阻塞状态</li><li>非阻塞IO，不断的检查数据是否准备好，如果没有直接返回一个错误码，第二阶段也是阻塞的</li><li>IO多路复用，可以看到IO多路复用阶段1和阶段2都是阻塞的，但是不同的是，IO多路复用在阶段1可以同时处理多个文件描述符，这使得在原本用多个线程完成的任务可以在一个线程中完成，但从流程上看，IO多路复用还是阻塞的IO，并且是同步IO。</li><li>信号量驱动的IO使用信号来通知数据是否准备好，当数据准备好了才通知线程继续处理，所以阶段1是非阻塞的，但是阶段2仍然是阻塞的过程。</li><li>异步IO，异步IO不论是阶段1还是阶段2都是非阻塞的，调用异步IO接口后，函数会立即返回，当数据成功拷贝到用户空间后再通知用户程序继续处理。</li></ul><p>从上图看来，前四种IO模型在第2阶段的处理都是一样的，而在第1阶段的处理方式不同。<br>Java nio的实现是基于IO多路复用实现的，它实现了在同一线程下处理多个文件描述符的功能，这种功能使得应用程序避免了因为线程切换而导致的性能损失。IO多路复用的实现需要系统调用的支持，例如select/poll/epoll,因为本文重点不在这里，所以不详述，可以参考文末的参考文献。</p><h2 id="基础BIO-Server"><a href="#基础BIO-Server" class="headerlink" title="基础BIO Server"></a>基础BIO Server</h2><p>从这里开始，我们开始用Java API来写一个server和client通信，以此来探索Java对不同io方式的支持。<br>首先是最基础的bio，使用ServerSocket API构建一个简单的服务器，基本的过程如下</p><ul><li>初始化ServerSocket</li><li>绑定ServerSocket到一个InetSocketAddress(ip,port)</li><li>调用accept()方法获取客户端socket,这个方法是阻塞的</li><li>通过client socket获取对应的inputStream和outputStream读取客户端的信息，并通过outputStream写回信息</li></ul><p>主要的代码实现如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">ServerSocket serverSocket=<span class="keyword">null</span>;</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">serverSocket=<span class="keyword">new</span> ServerSocket();</div><div class="line">serverSocket.bind(<span class="keyword">new</span> InetSocketAddress(<span class="string">"127.0.0.1"</span>, <span class="number">8888</span>));</div><div class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</div><div class="line">Socket client=serverSocket.accept();</div><div class="line">client.setSoTimeout(<span class="number">1000</span>);<span class="comment">//客户端read要在1秒内返回，不然认为是IO异常</span></div><div class="line">System.out.println(<span class="string">"get connection:"</span>+client);</div><div class="line">InputStream input=client.getInputStream();</div><div class="line">BufferedReader reader=<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(input));</div><div class="line">BufferedWriter writer=<span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(client.getOutputStream()));</div><div class="line"></div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</div><div class="line">String clientWord= reader.readLine();</div><div class="line">client.sendUrgentData(<span class="number">0</span>);<span class="comment">//发送心跳包，如果客户端断开连接，则出现IO异常</span></div><div class="line"><span class="keyword">if</span>(clientWord==<span class="keyword">null</span>)</div><div class="line"><span class="keyword">continue</span>;</div><div class="line">System.out.println(client.getRemoteSocketAddress()+<span class="string">":"</span>+clientWord);</div><div class="line"><span class="keyword">if</span>(<span class="string">"wenqi"</span>.equals(clientWord)) &#123;</div><div class="line">writer.write(<span class="string">"welcome admin wenqi!\n"</span>);</div><div class="line">writer.flush();</div><div class="line">&#125;<span class="keyword">else</span> &#123;</div><div class="line">writer.write(<span class="string">"welcome client "</span>+clientWord+<span class="string">"!\n"</span>);</div><div class="line">writer.flush();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;<span class="keyword">catch</span>(IOException e) &#123;</div><div class="line">reader.close();</div><div class="line">writer.close();</div><div class="line">client.close();</div><div class="line">System.out.println(<span class="string">"断开连接"</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在实际测试的过程中，有一个有趣的问题，如何判断客户端已经断开的连接，不管是正常的，还是不正常的服务端都要正确的处理，在上面的代码我们做的两种处理，一是设置client socket的setSoTimeout(time),这个api的作用是让client的read操作阻塞指定的时间，如果超过指定的时间就抛出SocketException(继承自IOException),强制断开与客户端的连接，这是服务端主动断开连接。<br>二是在实际情况下，如果客户端断开了连接，服务端并不知道客户端已经断开了连接，并且会一直读到null,这时候服务端在每次读取信息之前就要检查客户端是否还处于连接的状态，我们用sendUrgentData()去判断客户端是否处于连接的状态，如果不是则会抛出IOException，这样，服务端就知道了客户端已经断开了连接，可以关闭连接，不然的话，服务器会一直处于忙等的状态，并且无法处理其他的连接请求。<br>另外需要注意的是每次用write发送信息的时候必须用\n标注一行信息的结束，并且用flush刷新才会发送过去。<br>我们在每个客户端的逻辑中连续给服务端发送了两条信息，并且开启了10个线程的客户端，每个客户端主要逻辑如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">Socket client=<span class="keyword">new</span> Socket(<span class="string">"127.0.0.1"</span>, <span class="number">8888</span>);</div><div class="line">OutputStream out=client.getOutputStream();</div><div class="line">InputStream input=client.getInputStream();</div><div class="line"></div><div class="line">BufferedWriter writer=<span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(out));</div><div class="line">BufferedReader reader=<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(input));</div><div class="line">writer.write(<span class="string">"wenqi\n"</span>);</div><div class="line">writer.flush();</div><div class="line">String clientWord=reader.readLine();</div><div class="line">System.out.println(<span class="string">"server response to "</span>+num+<span class="string">"-"</span>+clientWord);</div><div class="line"></div><div class="line">writer.write(<span class="string">"good-"</span>+num+<span class="string">"\n"</span>);</div><div class="line">writer.flush();</div><div class="line">String clientWord2=reader.readLine();</div><div class="line">System.out.println(<span class="string">"server response to "</span>+num+<span class="string">"-"</span>+clientWord2);</div><div class="line"></div><div class="line">writer.close();</div><div class="line">reader.close();</div><div class="line">client.close();</div></pre></td></tr></table></figure></p><p>基础bio的全部代码可以点击<a href="https://github.com/buwenqi/JavaBasis/tree/master/src/main/java/bio" target="_blank" rel="external">这里</a></p><h2 id="基于线程池的BIO-Server"><a href="#基于线程池的BIO-Server" class="headerlink" title="基于线程池的BIO Server"></a>基于线程池的BIO Server</h2><p>上面的Server可以顺利的处理10个客户端的连接，这得益于我们对服务器和客户端不同状态的正确处理，单从整个过程来看，我们必须串行的逐个处理每个请求，这在并行大行其道的今天，没有让我们用到多处理器并发的优势，在这一节，我们将接受客户端连接放在主线程里，把对每个client socket的读写任务放到每个子线程中去运行，实现这个想法有两种做法：一种是为每个连接开启一个线程，另一种是使用线程池，在少量连接情况的第一种做法是是比较合理的，但是如果在短时间有大量连接的情况下，第二种方案合理，我们使用线程池的方式实现。<br>在Java中，我们可以通过如下API开启一个固定数目的线程池<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ExecutorService pool=Executors.newFixedThreadPool(number)</div></pre></td></tr></table></figure></p><p>其他的处理逻辑不变,主要逻辑代码如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">ServerSocket server=<span class="keyword">null</span>;</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">server=<span class="keyword">new</span> ServerSocket();</div><div class="line">server.bind(<span class="keyword">new</span> InetSocketAddress(<span class="string">"127.0.0.1"</span>, <span class="number">8888</span>));</div><div class="line"></div><div class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</div><div class="line">Socket client=server.accept();</div><div class="line">client.setSoTimeout(<span class="number">10000</span>);</div><div class="line">pool.submit(()-&gt;&#123;</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">BufferedReader reader=<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(client.getInputStream()));</div><div class="line">BufferedWriter writer=<span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(client.getOutputStream()));</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</div><div class="line">String clientWord= reader.readLine();</div><div class="line">client.sendUrgentData(<span class="number">0</span>);<span class="comment">//发送心跳包，如果客户端断开连接，则出现IO异常</span></div><div class="line"><span class="keyword">if</span>(clientWord==<span class="keyword">null</span>)</div><div class="line"><span class="keyword">continue</span>;</div><div class="line">System.out.println(client.getRemoteSocketAddress()+<span class="string">":"</span>+clientWord);</div><div class="line"><span class="keyword">if</span>(<span class="string">"wenqi"</span>.equals(clientWord)) &#123;</div><div class="line">writer.write(<span class="string">"welcome admin wenqi!\n"</span>);</div><div class="line">writer.flush();</div><div class="line">&#125;<span class="keyword">else</span> &#123;</div><div class="line">writer.write(<span class="string">"welcome client "</span>+clientWord+<span class="string">"!\n"</span>);</div><div class="line">writer.flush();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;<span class="keyword">catch</span>(IOException e) &#123;</div><div class="line">System.out.println(<span class="string">"断开连接"</span>);</div><div class="line">&#125;</div><div class="line">reader.close();</div><div class="line">writer.close();</div><div class="line">client.close();</div><div class="line">&#125;<span class="keyword">catch</span>(IOException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">&#125;);</div><div class="line">&#125;</div><div class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line"><span class="comment">// TODO Auto-generated catch block</span></div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="基础的NIO-Server-Client交互过程"><a href="#基础的NIO-Server-Client交互过程" class="headerlink" title="基础的NIO Server-Client交互过程"></a>基础的NIO Server-Client交互过程</h2><p>Java的BIO是面向缓冲区和通道的，面向缓冲区的意思是说数据是要写到缓冲区中，然后将缓冲区的数据通过通道出去, 其中最常用的缓冲区是ByteBuffer，它有四个重要属性：</p><ol><li>capacity，缓冲区的容量</li><li>position，最后一个元素的下一个位置</li><li>mark，当position需要变化时存储position</li><li>limit，最大能读入或写出的位置</li></ol><p>在写入缓冲区后，读取缓冲区需要调用flip()方法，这个方法的作用是将limit=position，将position置为0，然后才可以成功读取。<br>Channel分为4种：</p><ol><li>FileChannel从文件读写数据</li><li>DatagramChannel以UDP的形式从网络中读写数据</li><li>SocketChannel以TCP的形式从网络中读写数据</li><li>ServerSocketChannel可以开启一个非阻塞的ServerSocket</li></ol><p>我在<a href="https://github.com/buwenqi/JavaBasis/tree/master/src/main/java/nio/nioexample" target="_blank" rel="external">这里</a>写了一个简单的例子使用ServerSocketChannel和SocketChannel使用ByteBuffer进行一次对话的例子其主要过程如下：<br>Server端：</p><ol><li>使用ServerSocketChannel.open()开启一个server</li><li>使用bind方法绑定server到指定的InetSocketAddress</li><li>使用accept()方法获取客户端的SocketChannel</li><li>使用allocate()方法初始化一个ByteBuffer</li><li>使用client SocketChannel读取数据写入到ByteBuffer</li><li>byteBuffer flip()之后，读取数据并打印输出</li></ol><p>Java代码如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">ServerSocketChannel server=ServerSocketChannel.open();</div><div class="line">server.bind(<span class="keyword">new</span> InetSocketAddress(<span class="string">"127.0.0.1"</span>, <span class="number">8888</span>));</div><div class="line"></div><div class="line">SocketChannel client=server.accept();</div><div class="line">System.out.println(<span class="string">"执行"</span>);</div><div class="line">ByteBuffer byteBuffer=ByteBuffer.allocate(<span class="number">128</span>);</div><div class="line"><span class="keyword">int</span> size=client.read(byteBuffer);</div><div class="line">System.out.println(<span class="string">"读取了"</span>+size+<span class="string">"字节"</span>);</div><div class="line"></div><div class="line">byteBuffer.flip();</div><div class="line">String clientworld=<span class="keyword">new</span> String(byteBuffer.array(),<span class="number">0</span>,size);</div><div class="line">System.out.println(clientworld);</div><div class="line"></div><div class="line">server.close();</div><div class="line">client.close();</div></pre></td></tr></table></figure></p><p>Client端：</p><ol><li>使用SocketChannel.open()开启一个client</li><li>使用connect方法连接对应的InetSocketAddress</li><li>使用allocate()方法初始化一个ByteBuffer</li><li>写入数据后flip()，然后用write方法写入数据</li></ol><p>Client端代码如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">SocketChannel client=SocketChannel.open();</div><div class="line">client.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">"127.0.0.1"</span>, <span class="number">8888</span>));</div><div class="line">ByteBuffer writeBuffer=ByteBuffer.allocate(<span class="number">128</span>);</div><div class="line">writeBuffer.put(<span class="string">"hello world!"</span>.getBytes());</div><div class="line">writeBuffer.flip();</div><div class="line"></div><div class="line">client.write(writeBuffer);</div><div class="line">client.close();</div></pre></td></tr></table></figure></p><p>全部代码可以点击<a href="https://github.com/buwenqi/JavaBasis/tree/master/src/main/java/nio/nioexample" target="_blank" rel="external">这里</a><br>值得注意的是，在每次需要从对buffer填充后，需要调用flip()才可以读取buffer中的数据。</p><h2 id="单Selector的NIO-Server实现"><a href="#单Selector的NIO-Server实现" class="headerlink" title="单Selector的NIO Server实现"></a>单Selector的NIO Server实现</h2><p>在上面的例子，我们仅仅使用到Socket Channel演示了进行远程通信的一个过程，当然Socket Channel的非阻塞性质并没有显示出来，接下来，我们使用非阻塞Socket来实现一个Client-Server通信。<br>不论是使用ServerSocketChannel还是SocketChannel都可以通过<code>configureBlocking</code>方法设置为非阻塞Channel,这个方法的意义不仅仅是在执行阻塞方法的时候直接返回，如果我们深入查看，这个方法是来自于ServerSocketChannel和SocketChannel的共同父类SelectableChannel，这个方法更深层次的含义是非阻塞IO和选择性是紧密相关的，实验证明Java必须将Channel设置为非阻塞的才能进行选择。<br>最后，另外一个重要的类<strong>Selector</strong>，这个类是实现Java IO多路复用的重要类，它的功能在于两方面：一是非阻塞的Channel可以使用<code>register</code>方法注册感兴趣的阻塞事件，另一方面它可以通过<code>select</code>方法选出已经准备就绪的阻塞事件做进一步的处理。这在多用户连接client-server模式下这种处理方式是很有用的，一方面，每个连接的client连接成功后都可以注册读事件，另一方面服务器可以挑选已经就绪的client进行操作，而不必要仅仅等一个client的读，相比阻塞的Socket处理模式这大大提高了cpu的利用率。<br>还有一个重要的类<strong>SelectionKey</strong>,选择好就绪的事件后，<code>selector.selectedKeys()</code>会返回一个就绪的事件集合，根据获取到key，我们可以选择不同的处理方法做进一步的处理。另一个值得注意的问题是在处理完一个key之后注意在key集合中除去它，防止多次处理。单个用户多次发送接受的情况处理用client.read()读取的长度进行判断，如果等于-1，我们就认为客户端断开了。<br>关于整体的工作示意图如下<br><img src="https://i.imgur.com/NkG0ja3.png" alt=""><br>从整个图中可以看到Selector在整个过程中具有举足轻重的作用，如果从Reactor模式的角度来看，Selector的select()方法实现了Event Demultiplexer角色的就绪事件的选取，并且和处理注册兴趣事件的Handle角色以及处理事件分发的Dispatcher角色右直接的关联。<br>以下是我们实现的Java NIO的服务器实例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//开启一个server</span></div><div class="line">ServerSocketChannel server = ServerSocketChannel.open();</div><div class="line">server.bind(<span class="keyword">new</span> InetSocketAddress(<span class="string">"127.0.0.1"</span>, <span class="number">8888</span>));</div><div class="line"><span class="comment">//设置server的accept为非阻塞模式</span></div><div class="line">server.configureBlocking(<span class="keyword">false</span>);</div><div class="line"></div><div class="line"><span class="comment">//设置Selector</span></div><div class="line">Selector selector=Selector.open();</div><div class="line"><span class="comment">//为server注册selector感兴趣的事件</span></div><div class="line">server.register(selector, SelectionKey.OP_ACCEPT);</div><div class="line"></div><div class="line"><span class="comment">//准备好读写的缓冲区</span></div><div class="line">ByteBuffer readBuffer=ByteBuffer.allocate(<span class="number">128</span>);</div><div class="line">ByteBuffer writeBuffer=ByteBuffer.allocate(<span class="number">128</span>);</div><div class="line"></div><div class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</div><div class="line"><span class="comment">//阻塞直到有通道被选择</span></div><div class="line">selector.select();</div><div class="line">Set&lt;SelectionKey&gt; keys=selector.selectedKeys();</div><div class="line">Iterator&lt;SelectionKey&gt;iterator=keys.iterator();</div><div class="line"><span class="keyword">while</span>(iterator.hasNext()) &#123;</div><div class="line">SelectionKey key=iterator.next();</div><div class="line"><span class="comment">//将当前key从selector的中删除,这样在下一次这个key就不会出现</span></div><div class="line">iterator.remove();</div><div class="line"><span class="keyword">if</span>(key.isAcceptable()) &#123;</div><div class="line">SocketChannel client=server.accept();</div><div class="line">System.out.println(<span class="string">"accept connection from "</span>+client);</div><div class="line"><span class="comment">//设置client socket对都不阻塞</span></div><div class="line">client.configureBlocking(<span class="keyword">false</span>);</div><div class="line"><span class="comment">//将client注册为可读，放入selector</span></div><div class="line">client.register(selector, SelectionKey.OP_READ);</div><div class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(key.isReadable()) &#123;</div><div class="line">SocketChannel client=(SocketChannel) key.channel();</div><div class="line">readBuffer.clear();</div><div class="line"><span class="keyword">int</span> size=client.read(readBuffer);</div><div class="line"><span class="keyword">if</span>(size!=-<span class="number">1</span>) &#123;</div><div class="line">readBuffer.flip();<span class="comment">//不可少</span></div><div class="line">String clientWord=<span class="keyword">new</span> String(readBuffer.array(),<span class="number">0</span>,size);</div><div class="line"><span class="comment">//改变key为写信号</span></div><div class="line">key.interestOps(SelectionKey.OP_WRITE);</div><div class="line"><span class="comment">//根据客户传送的信息附带不同的信息</span></div><div class="line"><span class="keyword">if</span>(<span class="string">"wenqi"</span>.equals(clientWord)) &#123;</div><div class="line">key.attach(<span class="string">"welcome admin wenqi!"</span>);</div><div class="line">&#125;<span class="keyword">else</span> &#123;</div><div class="line">key.attach(<span class="string">"welcome client "</span>+clientWord+<span class="string">"!"</span>);</div><div class="line">&#125;</div><div class="line">&#125;<span class="keyword">else</span> &#123;</div><div class="line">System.out.println(<span class="string">"client closed:"</span>+client);</div><div class="line">key.cancel();</div><div class="line">client.close();</div><div class="line">&#125;</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(key.isWritable()) &#123;<span class="comment">//isWritable有是否准备好&amp;SelectionKey决定</span></div><div class="line">SocketChannel client=(SocketChannel) key.channel();</div><div class="line">String backword=(String) key.attachment();</div><div class="line">writeBuffer.clear();</div><div class="line">writeBuffer.put(backword.getBytes());</div><div class="line">writeBuffer.flip();</div><div class="line">client.write(writeBuffer);</div><div class="line">key.interestOps(SelectionKey.OP_READ);</div><div class="line"><span class="comment">//不允许多次读写用cancel</span></div><div class="line"><span class="comment">//key.cancel();</span></div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>我们在客户端开启了10个线程模拟10个用户连接，并且每个用户给服务端发送两条不同的信息，以此来测试服务器，全部的代码可以点击<a href="https://github.com/buwenqi/JavaBasis/blob/master/src/main/java/nio/NIOServer.java" target="_blank" rel="external">这里</a>。<br>在实现的过程中遇到几个问题，解决后总结如下</p><ul><li>当从selector.selectedKeys()中取出一个key处理后，必须将其从集合中删除，不然会重复处理</li><li>read，write的key删除后在下一轮还是存活，探究许久这个不知所以然，这使得我们可以变更key的interestOps实现多轮读写，但是我们必须在读中判断师傅可读现在，现在的解决方法是通过read的返回值为-1判定客户端断开（-1 if the channel has reached end-of-stream）。</li></ul><h2 id="将读写任务分离出去的单Selector服务器实现"><a href="#将读写任务分离出去的单Selector服务器实现" class="headerlink" title="将读写任务分离出去的单Selector服务器实现"></a>将读写任务分离出去的单Selector服务器实现</h2><p>虽然我们使用Selector实现了在单线程处理多个请求的功能，但从整个过程来仍然串行的，接受连接，读写数据，每次我们只能执行一项任务，终归到底我们是一个线程，如果读写数据的过程比较长，那么整个服务器就被阻塞在读写任务那里，不能再接受新连接请求，这是我们不愿意看到的。另一方面，多处理器的优势我们没有用到，想到这里，我们很自然的想到将读写任务从主线程解放出来，通过子线程完成读写任务，主线程只关心出来连接，分发读写任务，所以，我们的整个过程变成了下面这样。<br><img src="https://i.imgur.com/YWoOlo9.png" alt=""><br>因为将读写任务交给了子线程，主线程就可以继续轮询处理其他时间，但是有个问题，正在处理的读写事件并没有从SelectionKeys里面剔除除去，下一次轮询仍然有这个读事件，只不过读出的是空而已。一个解决方法是使用cancel取消key，在完成了写任务后再重新注册key，另一个方法是建立一个在读队列，每次处理key之前看是否在队列中，如果在的话不处理，在完成读写任务后，子线程将现在的key从队列中移除，我采用了第二种方案。<br>在主线程上，我们做了一下改变</p><ol><li>加入了正在读写队列，在2处进行了逻辑判断</li><li>在3处读操作交给了子线程池处理Worker</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//读写操作处理器</span></div><div class="line">IWorker readProcessor=<span class="keyword">new</span> Worker();</div><div class="line"></div><div class="line"><span class="comment">//进入读写状态的队列</span></div><div class="line">Queue&lt;SelectionKey&gt; operateQueue=<span class="keyword">new</span> LinkedList&lt;&gt;();<span class="comment">//1</span></div><div class="line"></div><div class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</div><div class="line"><span class="comment">//阻塞直到有通道被选择</span></div><div class="line">selector.select();</div><div class="line">Set&lt;SelectionKey&gt; keys=selector.selectedKeys();</div><div class="line">Iterator&lt;SelectionKey&gt;iterator=keys.iterator();</div><div class="line"><span class="keyword">while</span>(iterator.hasNext()) &#123;</div><div class="line">SelectionKey  key=iterator.next();</div><div class="line"><span class="comment">//将当前key从selector的中删除,这样在下一次这个key就不会出现</span></div><div class="line">iterator.remove();</div><div class="line"><span class="keyword">if</span>(operateQueue.contains(key)) <span class="comment">//2</span></div><div class="line"><span class="keyword">continue</span>;</div><div class="line"><span class="keyword">if</span>(key.isAcceptable()) &#123;</div><div class="line">SocketChannel client=server.accept();</div><div class="line">System.out.println(<span class="string">"accept connection from "</span>+client.getRemoteAddress());</div><div class="line"><span class="comment">//设置client socket对都不阻塞</span></div><div class="line">client.configureBlocking(<span class="keyword">false</span>);</div><div class="line"><span class="comment">//将client注册为可读，放入selector</span></div><div class="line">client.register(selector, SelectionKey.OP_READ);</div><div class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(key.isReadable()) &#123;</div><div class="line"><span class="comment">//分发给Read线程池处理(从内核空间拷贝到用户空间)</span></div><div class="line">operateQueue.offer(key);</div><div class="line">readProcessor.process(key,operateQueue); <span class="comment">//3</span></div><div class="line">&#125; </div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>Worker的主要逻辑如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">pool.submit(()-&gt;&#123; </div><div class="line">SocketChannel client=<span class="keyword">null</span>;</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">ByteBuffer readBuffer=ByteBuffer.allocate(<span class="number">128</span>);</div><div class="line">client=(SocketChannel)key.channel();</div><div class="line"><span class="keyword">int</span> size=client.read(readBuffer);</div><div class="line"><span class="keyword">if</span>(size!=-<span class="number">1</span>) &#123;</div><div class="line">readBuffer.flip();</div><div class="line">String clientWord=<span class="keyword">new</span> String(readBuffer.array(),<span class="number">0</span>,size);</div><div class="line">System.out.println(<span class="string">"clientWord:"</span>+clientWord);</div><div class="line"></div><div class="line"><span class="keyword">if</span>(<span class="string">"wenqi"</span>.equals(clientWord)) &#123;</div><div class="line">key.attach(<span class="string">"welcome admin wenqi!"</span>);</div><div class="line">writeProcess(key);</div><div class="line">&#125;<span class="keyword">else</span> &#123;</div><div class="line">key.attach(<span class="string">"welcome client "</span>+clientWord+<span class="string">"!"</span>);</div><div class="line">writeProcess(key);</div><div class="line">&#125;</div><div class="line">operateQueue.remove(key);</div><div class="line"></div><div class="line">&#125;<span class="keyword">else</span> &#123;</div><div class="line">client.close();</div><div class="line">key.cancel();</div><div class="line">System.out.println(<span class="string">"client close:"</span>+client);</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;<span class="keyword">catch</span>(IOException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">client.close();</div><div class="line">key.cancel();</div><div class="line">System.out.println(<span class="string">"client close:"</span>+client);</div><div class="line">&#125; <span class="keyword">catch</span> (IOException e1) &#123;</div><div class="line"><span class="comment">// TODO Auto-generated catch block</span></div><div class="line">e1.printStackTrace();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p><p>全部代码请看<a href="https://github.com/buwenqi/JavaBasis/blob/master/src/main/java/nio/NIOServerConcurrent.java" target="_blank" rel="external">这里</a></p><h2 id="使用多Selector进一步解放主线程任务"><a href="#使用多Selector进一步解放主线程任务" class="headerlink" title="使用多Selector进一步解放主线程任务"></a>使用多Selector进一步解放主线程任务</h2><p>将读写任务分离出去的单Selector服务器实现虽然实现了将读写任务交给了子线程，但是主线程还是要识别并分发read，write时间，那么我们进一步划分任务，让主线程的Selector仅处理accept时间，而将接受到的Client Socket的读写时间交给另一个Selector去处理，岂不更好，说做就做，进一步改进。我们的结构图改成了这样<br><img src="https://i.imgur.com/En4yXug.png" alt=""><br>主要代码如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//开启一个server</span></div><div class="line">ServerSocketChannel server = ServerSocketChannel.open();</div><div class="line">server.bind(<span class="keyword">new</span> InetSocketAddress(<span class="string">"127.0.0.1"</span>, <span class="number">8888</span>));</div><div class="line"><span class="comment">//设置server的accept为非阻塞模式</span></div><div class="line">server.configureBlocking(<span class="keyword">false</span>);</div><div class="line"></div><div class="line"><span class="comment">//设置Selector</span></div><div class="line">Selector selector=Selector.open();</div><div class="line"><span class="comment">//为server注册selector感兴趣的事件</span></div><div class="line">server.register(selector, SelectionKey.OP_ACCEPT);</div><div class="line"></div><div class="line"><span class="comment">//获取多Reactor模式下的子Reactor处理器</span></div><div class="line"><span class="keyword">int</span> coreNum=Runtime.getRuntime().availableProcessors();</div><div class="line">System.out.println(<span class="string">"得到"</span>+coreNum+<span class="string">"处理器单元"</span>);</div><div class="line">Processor[] processors=<span class="keyword">new</span> Processor[coreNum];</div><div class="line"><span class="keyword">int</span> index=<span class="number">0</span>;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;coreNum;i++) &#123;</div><div class="line">processors[i]=<span class="keyword">new</span> Processor();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</div><div class="line"><span class="comment">//阻塞直到有通道被选择</span></div><div class="line">selector.select();</div><div class="line">Set&lt;SelectionKey&gt; keys=selector.selectedKeys();</div><div class="line">Iterator&lt;SelectionKey&gt;iterator=keys.iterator();</div><div class="line"><span class="keyword">while</span>(iterator.hasNext()) &#123;</div><div class="line">SelectionKey  key=iterator.next();</div><div class="line"><span class="comment">//将当前key从selector的中删除,这样在下一次这个key就不会出现</span></div><div class="line">iterator.remove();</div><div class="line"><span class="keyword">if</span>(key.isAcceptable()) &#123;</div><div class="line">SocketChannel client=server.accept();</div><div class="line">System.out.println(<span class="string">"accept connection from "</span>+client.getRemoteAddress());</div><div class="line"><span class="comment">//设置client socket对都不阻塞</span></div><div class="line">client.configureBlocking(<span class="keyword">false</span>);</div><div class="line">Processor processor=processors[index%coreNum];</div><div class="line">index=(index+<span class="number">1</span>)%coreNum;</div><div class="line">processor.wakeup();</div><div class="line">processor.addChannel(client);</div><div class="line"></div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>子Selector的处理代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Processor</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="keyword">private</span> ExecutorService pool=Executors.newFixedThreadPool(<span class="number">2</span>*Runtime.getRuntime().availableProcessors());</div><div class="line"><span class="keyword">private</span> Selector selector;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Processor</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">selector=SelectorProvider.provider().openSelector();</div><div class="line">process();</div><div class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line"><span class="comment">// TODO Auto-generated catch block</span></div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">addChannel</span><span class="params">(SocketChannel client)</span> </span>&#123;</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line"><span class="comment">//会被select()阻塞掉的</span></div><div class="line">client.register(selector, SelectionKey.OP_READ);</div><div class="line"><span class="comment">//selector.wakeup();</span></div><div class="line">&#125; <span class="keyword">catch</span> (ClosedChannelException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wakeup</span><span class="params">()</span> </span>&#123;</div><div class="line">selector.wakeup();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">()</span> </span>&#123;</div><div class="line">pool.execute(()-&gt;&#123;</div><div class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line"><span class="comment">//使用select()会有一个问题，wakeup后如果继续主线程的register如果没有执行</span></div><div class="line"><span class="comment">//，会进入下一个select阻塞状态，register还是无法执行</span></div><div class="line"><span class="keyword">if</span>(selector.select(<span class="number">500</span>)&lt;=<span class="number">0</span>)</div><div class="line"><span class="keyword">continue</span>;</div><div class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line"><span class="comment">// TODO Auto-generated catch block</span></div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">Set&lt;SelectionKey&gt; keys=selector.selectedKeys();</div><div class="line">Iterator&lt;SelectionKey&gt; iterator=keys.iterator();</div><div class="line"><span class="keyword">while</span>(iterator.hasNext()) &#123;</div><div class="line">SelectionKey key=iterator.next();</div><div class="line">iterator.remove();</div><div class="line"><span class="keyword">if</span>(key.isReadable()) &#123;</div><div class="line">SocketChannel client=<span class="keyword">null</span>;</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">ByteBuffer readBuffer=ByteBuffer.allocate(<span class="number">128</span>);</div><div class="line">client=(SocketChannel)key.channel();</div><div class="line"><span class="keyword">int</span> size=client.read(readBuffer);</div><div class="line"><span class="keyword">if</span>(size!=-<span class="number">1</span>) &#123;</div><div class="line">readBuffer.flip();</div><div class="line">String clientWord=<span class="keyword">new</span> String(readBuffer.array(),<span class="number">0</span>,size);</div><div class="line">System.out.println(<span class="string">"clientWord:"</span>+clientWord);</div><div class="line"></div><div class="line"><span class="keyword">if</span>(<span class="string">"wenqi"</span>.equals(clientWord)) &#123;</div><div class="line">key.attach(<span class="string">"welcome admin wenqi!"</span>);</div><div class="line">writeProcess(key);</div><div class="line">&#125;<span class="keyword">else</span> &#123;</div><div class="line">key.attach(<span class="string">"welcome client "</span>+clientWord+<span class="string">"!"</span>);</div><div class="line">writeProcess(key);</div><div class="line">&#125;</div><div class="line">&#125;<span class="keyword">else</span> &#123;</div><div class="line">client.close();</div><div class="line">key.cancel();</div><div class="line">System.out.println(<span class="string">"client close:"</span>+client);</div><div class="line">&#125;</div><div class="line">&#125;<span class="keyword">catch</span>(IOException e) &#123;</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">client.close();</div><div class="line">key.cancel();</div><div class="line">System.out.println(<span class="string">"client close:"</span>+client);</div><div class="line">&#125;<span class="keyword">catch</span>(IOException e2) &#123;</div><div class="line">e2.printStackTrace();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeProcess</span><span class="params">(SelectionKey key)</span> </span>&#123;</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">ByteBuffer writeBuffer=ByteBuffer.allocate(<span class="number">128</span>);</div><div class="line">SocketChannel client=(SocketChannel) key.channel();</div><div class="line">String backword=(String) key.attachment();</div><div class="line">System.out.println(<span class="string">"writing:"</span>+backword);</div><div class="line">writeBuffer.put(backword.getBytes());</div><div class="line">writeBuffer.flip();</div><div class="line">client.write(writeBuffer);</div><div class="line">&#125;<span class="keyword">catch</span>(IOException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在实现的过程中，我们使用遇到了一个问题，就是在<code>client.register(selector, SelectionKey.OP_READ);</code>注册Client到子Selector中时出现了死锁，经过多次查找资料，在一个论坛里找到了答案（点击<a href="http://www.iteye.com/topic/768446" target="_blank" rel="external">这里</a>，感谢！),原来register方法在select方法阻塞的过程中是也是阻塞的，尽管我们使用wakeup方法使得select方法立即返回，但是也不保证在下一次select方法调用之前执行了register方法，所以最好使用有有效期限的select(time)方法，这样就可以使得正确执行。看来以后遇到问题要先认真看官方文档了。</p><h2 id="关于源码"><a href="#关于源码" class="headerlink" title="关于源码"></a>关于源码</h2><p>你可以在<a href="https://github.com/buwenqi/JavaBasis/tree/master/src/main/java/nio" target="_blank" rel="external">这里</a>找到本文的所以源码，你同时可以在<a href="https://buwenqi.github.io" target="_blank" rel="external">我的博客</a>看到这篇文章，欢迎批评指正。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="http://www.jasongj.com/java/nio_reactor/" target="_blank" rel="external">Java I/O模型从BIO到NIO和Reactor模式</a><br><a href="https://www.ziwenxie.site/2017/08/22/java-nio/" target="_blank" rel="external">Java并发编程之NIO简明教程</a><br><a href="https://www.ziwenxie.site/2017/01/02/unix-network-programming-asynchronous/" target="_blank" rel="external">Linux下的五种IO模型</a><br><a href="https://www.cnblogs.com/jeakeven/p/5435916.html" target="_blank" rel="external">IO多路复用之select、poll、epoll详解</a><br><a href="http://www.blogjava.net/DLevin/archive/2015/09/02/427045.html" target="_blank" rel="external">Reactor模式详解</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章先从阻塞与非阻塞，同步与异步之间的定义和关系说起，然后探讨liunx下的5种IO模型，支持非阻塞IO的select/poll/epoll系统调用的基本原理，然后通过Java代码搭建bio方式的服务端，改进服务器在并发场景下bio多线程和线程池的实现方式，最后介绍Java nio来实现一个服务器和多个客户端对话。&lt;br&gt;
    
    </summary>
    
    
      <category term="Java基础" scheme="http://yoursite.com/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>MySQL-SQL之索引</title>
    <link href="http://yoursite.com/2017/11/30/MySQL-SQL%E4%B9%8B%E7%B4%A2%E5%BC%95/"/>
    <id>http://yoursite.com/2017/11/30/MySQL-SQL之索引/</id>
    <published>2017-11-30T03:09:19.000Z</published>
    <updated>2018-02-21T14:26:34.723Z</updated>
    
    <content type="html"><![CDATA[<p>索引具有加快数据库服务器查询数据的速度的作用，其作用目的是为将经常作用于查询标志（比如where语句的查询条件）的列新建一个数据结构，这个数据结构的每一个元素通常包含两个信息：索引列的值和索引值所执行的数据行的地址。<br><a id="more"></a></p><h2 id="关于索引"><a href="#关于索引" class="headerlink" title="关于索引"></a>关于索引</h2><p>从对索引的实现算法上，最常见的是使用B+ Tree的数据结构，另外还有位图，全文索引的实现方式，这些算法实现对应于应对不同索引的应用场景，B+ Tree应用场景比较普遍，其更擅长于处理索引值含有不同值的列，其查询速度可以维持在log(N)的时间复杂度，而位图算法适合有大量行但是有较少值的情况,一个具体形象的例子是银行卡的类型仅仅有储蓄账户，支票账户等等几种，而银行卡信息却有很多，如果要对银行卡类型建立索引，位图算法是个好的选择。全文索引策略适用于对文字较多的列建立索引。<br>当前mysql对索引策略的支持如下表所示<br><img src="https://i.imgur.com/aEBwjuZ.png" alt=""><br>除了我们上面提到的BTree,FullText,上面还出现了RTree,Hash等策略，hash算法是通过要索引的值获取一个hash值，并且根据hash值建立索引，rtree相对于b-tree的优势在于范围查找，不是很常用。<br>按照功能性来分的话，mysql索引又分为普通索引，唯一索引，主键索引，全文索引，外键索引和组合索引，我们既可以在创建表时创建索引，又可以在之后通过修改表的方式添加索引，我们用后面一种方式做例子</p><ol><li>添加普通索引语法：<code>alter table    表名 add index 索引名(列名)</code></li><li>添加唯一索引，这种索引会限制索引列出现重复的值，语法<code>alter table 表名 add index unique 索引名(列名)</code></li><li>添加主键索引，这个mysql会自动帮我们加入，如果修改加入主键，可以使用<code>alter table 表名 add primary key(列名)</code></li><li>添加全文索引，<code>alter table 表名 add fulltext 索引名(列名)</code></li><li>添加外键索引，和添加外键一样，<code>alter table 表名 add foreign key(列名) references 参照表名(参照表列)</code></li></ol><p>使用explain命令处理select句，具体列的值可以参考<a href="http://overtrue.me/articles/2014/10/mysql-explain.html" target="_blank" rel="external">这里</a></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="http://blog.csdn.net/jesseyoung/article/details/38037543" target="_blank" rel="external">MySQL索引（index）专题</a><br><a href="http://overtrue.me/articles/2014/10/mysql-explain.html" target="_blank" rel="external">MySQL中EXPLAIN命令详解</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;索引具有加快数据库服务器查询数据的速度的作用，其作用目的是为将经常作用于查询标志（比如where语句的查询条件）的列新建一个数据结构，这个数据结构的每一个元素通常包含两个信息：索引列的值和索引值所执行的数据行的地址。&lt;br&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
</feed>
