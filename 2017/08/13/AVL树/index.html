<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="数据结构," />










<meta name="description" content="什么是AVL树？AVL树，又称为平衡二叉树，它是一种特殊的二叉查找树（Binary Search Tree, BST），其每一个节点的左右子树的高度差不超过1。
注意，一个节点的高度是从该节点到叶子节点的最长路径，所以，叶子节点的高度为0,而深度是指一个节点到树根的路径长度，两者是相反的概念。 一棵树的高度等于根节点的高度，而深度等于最大深度的叶子节点的深度，所以一个树的高度和深度是相同的。">
<meta property="og:type" content="article">
<meta property="og:title" content="AVL树">
<meta property="og:url" content="http://yoursite.com/2017/08/13/AVL树/index.html">
<meta property="og:site_name" content="Wenqi's Blog">
<meta property="og:description" content="什么是AVL树？AVL树，又称为平衡二叉树，它是一种特殊的二叉查找树（Binary Search Tree, BST），其每一个节点的左右子树的高度差不超过1。
注意，一个节点的高度是从该节点到叶子节点的最长路径，所以，叶子节点的高度为0,而深度是指一个节点到树根的路径长度，两者是相反的概念。 一棵树的高度等于根节点的高度，而深度等于最大深度的叶子节点的深度，所以一个树的高度和深度是相同的。">
<meta property="og:image" content="http://i.imgur.com/AqmG69f.png">
<meta property="og:image" content="http://i.imgur.com/zlbg3AE.png">
<meta property="og:image" content="http://i.imgur.com/eKBIJss.png">
<meta property="og:image" content="http://i.imgur.com/7Mdx4Mb.png">
<meta property="og:image" content="http://i.imgur.com/43Ib6g4.png">
<meta property="og:image" content="http://i.imgur.com/w4ZXMcy.png">
<meta property="og:image" content="http://i.imgur.com/bUBGV76.png">
<meta property="og:image" content="http://i.imgur.com/1rbM75o.jpg">
<meta property="og:image" content="http://i.imgur.com/QwnFE74.png">
<meta property="og:image" content="http://i.imgur.com/MTgzaxG.png">
<meta property="og:image" content="http://i.imgur.com/sAJ6KSt.png">
<meta property="og:updated_time" content="2018-02-21T14:26:34.717Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="AVL树">
<meta name="twitter:description" content="什么是AVL树？AVL树，又称为平衡二叉树，它是一种特殊的二叉查找树（Binary Search Tree, BST），其每一个节点的左右子树的高度差不超过1。
注意，一个节点的高度是从该节点到叶子节点的最长路径，所以，叶子节点的高度为0,而深度是指一个节点到树根的路径长度，两者是相反的概念。 一棵树的高度等于根节点的高度，而深度等于最大深度的叶子节点的深度，所以一个树的高度和深度是相同的。">
<meta name="twitter:image" content="http://i.imgur.com/AqmG69f.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"hide","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/08/13/AVL树/"/>





  <title>AVL树 | Wenqi's Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Wenqi's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-books">
          <a href="/books" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />
            
            读书记
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            勾搭
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/13/AVL树/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Wenqi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/me.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wenqi's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">AVL树</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-13T10:54:20+08:00">
                2017-08-13
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/08/13/AVL树/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2017/08/13/AVL树/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2017/08/13/AVL树/" class="leancloud_visitors" data-flag-title="AVL树">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="什么是AVL树？"><a href="#什么是AVL树？" class="headerlink" title="什么是AVL树？"></a>什么是AVL树？</h2><p>AVL树，又称为平衡二叉树，它是一种特殊的二叉查找树（Binary Search Tree, BST），其每一个节点的左右子树的高度差不超过1。</p>
<p>注意，一个节点的<strong>高度</strong>是从该节点到叶子节点的最长路径，所以，叶子节点的高度为0,而<strong>深度</strong>是指一个节点到树根的路径长度，两者是相反的概念。 一棵树的高度等于根节点的高度，而深度等于最大深度的叶子节点的深度，所以一个树的高度和深度是相同的。</p>
<a id="more"></a>
<p>二叉查找树的定义是递归的：1）左子树所有节点的值都比根节点小，右子树所有的节点都比根节点大，2）左子树和右子树都是二叉查找树。</p>
<p>当所有的插入序列都是等可能的情况下，二叉查找树的平均深度是O(log N)，但是当遇到极端情况（比如插入有序的序列）或者多次的插入\删除操作会使得二叉查找树的深度变大，而平衡二叉树加大了对二叉查找树的限制：任何一个节点的左右子树的高度差不能超过1，这就保证了平衡二叉树的深度为O(log N),使得平衡二叉树的最坏的查找效率是O(log N)，而二叉查找树的最坏查找效率可以是O(N)。那么问题的关键就是如何在插入和删除的时候保持平衡二叉树的性质。</p>
<h2 id="如何在插入一个节点的时候保持树的平衡？"><a href="#如何在插入一个节点的时候保持树的平衡？" class="headerlink" title="如何在插入一个节点的时候保持树的平衡？"></a>如何在插入一个节点的时候保持树的平衡？</h2><p>当插入一个新的节点的时候，如果插入的新节点使得一些节点的左右子树的高度差等于了2，那么这时候就需要旋转(rotation)来调整不平衡的子树，使得整个树仍然保持平衡二叉树的性质。导致<strong>不平衡</strong>插入只有四种情况：</p>
<ol>
<li>左左，即插入点为不平衡节点的左儿子的左子树中，使得原来平衡节点的左子树比右子树高1，变成现在变成高2了。</li>
<li>右右，即插入点为不平衡节点的右儿子的右子树中，使得原来平衡节点的右子树比左子树高1，变成现在变成高2了，他是第一种情况的对称情况</li>
<li>左右，即插入点为不平衡节点的左儿子的右子树中，使得原来平衡节点的左子树比右子树高1，变成现在变成高2了。</li>
<li>右左，即插入点为不平衡节点的右儿子的左子树中，使得原来平衡节点的右子树比左子树高1，变成现在的高2，它是第三种情况的堆成情况。</li>
</ol>
<p>我们先看前两种情况的处理方式（<strong>单旋转</strong>）:</p>
<p>左左的情况如下图1所示, k1为不平衡节点，由于新节点的插入到了X子树，使得k1的左子树的高度比右子树的高度差2，这时候，我们只需要做单旋转操作：1）把k1的右孩子变成k2(k1的左孩子)的右子树，2）把k2的左孩子变成k1,返回平衡后的树根k2。相同的图2显示了右右单旋转的操作过程</p>
<center><br><img src="http://i.imgur.com/AqmG69f.png" alt=""><br>图1：左左单旋转<br></center><br><center><br><img src="http://i.imgur.com/zlbg3AE.png" alt=""><br>图2：右右单旋转<br></center>

<p>如果不平衡情况是第3，4种，那么单选并不能使得树变平衡，以第3种情况为例，我们使用单旋转来改变树的形态，其过程如图3所示，显然，单旋转不能使得左右的不平衡的状态达到平衡。</p>
<center><br><img src="http://i.imgur.com/eKBIJss.png" alt=""><br>图3：单旋转不能处理左右不平衡的情况<br></center>

<p>那么第三种和第四种情况如何处理呢，我们不能再把k2提上去作为树的根了，那么如果我们把Y子树的根 作为新的树根呢，这是一个可行的方案，这就是<strong>双旋转</strong>最初的想法。</p>
<p>以第三种情况为例（见图4），也就是插入点位于不平衡节点的左孩子的右子树上，我需要两次旋转来调整树达到平衡，首先将k3（k2的右孩子）左旋转到k2的位置，然后在将k2通过单旋转到k1的位置，整个过程如图4所示，红线为需要变动的链接。其中，在k3左旋转到k2位置上时需要将k3的左子树变成k2的右子树，在k3右转到k1位置的时候需要将k3的右子树变成k1的右子树。图5展示了右左不平衡的情况的双旋转。</p>
<center><br><img src="http://i.imgur.com/7Mdx4Mb.png" alt=""><br>图4：左右双旋转<br></center><br><center><br><img src="http://i.imgur.com/43Ib6g4.png" alt=""><br>图5：右左双旋转<br></center>

<h2 id="Java-AVL树插入的实现"><a href="#Java-AVL树插入的实现" class="headerlink" title="Java AVL树插入的实现"></a>Java AVL树插入的实现</h2><p>在上面的解释中，我们有一个重要的问题没有解决，也就是在插入后如何确定<strong>不平衡点</strong>。实际上，我们在插入后需要进行回溯去找到不平衡的父节点，回溯的方法有多种，比如用<strong>栈</strong>存储插入节点对比的路径，从栈中取出存储信息，另一种方法是使用<strong>递归</strong>，其实也是隐式的使用栈的操作，再用一种是在树的结构中保持<strong>父节点</strong>的引用，但是这会占用更多的内存。我的实现使用了栈的操作，接着后面分析了&lt;数据结构与算法分析-Java语言描述&gt;一书中递归的实现，后者的实现更巧妙，是值得推荐的操作，我自己的使用栈的实现原则上是和它一样的，但是它能跟让我深刻的理解递归背后的详细操作。</p>
<p>另一个讨论是在回溯的过程中是否有必要回溯所有的父节点，答案是必要的，尽管我们在调整的时候只有一个节点需要调整，也就是在一次过程中我们最多调整一个不平衡节点就使得整个树归于平衡，但是我们需要更新所有父节点的平衡信息，这个信息可以是高度或者高度差，我们的实现中使用<strong>高度</strong>。</p>
<p>另外一个问题，单旋只需要单次旋转，而双旋需要两次旋转，其实现方式是否不同？ 其实从双旋的过程来看，其实现和单旋一样，都归结到<strong>左旋</strong>和<strong>右旋</strong>操作，也就是把右儿子调整到父节点的位置，或者把左儿子调整到父节点的位置，这是两个基本的操作。我们写出正两个基本操作的伪代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">描述：旋转一个节点的左孩子到父节点位置</div><div class="line">输入：待旋转节点k1</div><div class="line">输出：旋转后的树根</div><div class="line">	k2=k1的左孩子</div><div class="line">	让k1的左指针指向k2的右孩子</div><div class="line">	让k2的右指针指向k1</div><div class="line">	更新k1的高度信息为max(k1左孩子的高度，k1右孩子的高度）+1</div><div class="line">	更新k2的高度信息为max（k2左孩子的高度，k1的高度）+1</div><div class="line">	返回k2</div></pre></td></tr></table></figure></p>
<p>相同的，我们也可以写出旋转一个节点的右孩子到父节点的位置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">描述：旋转一个节点的右孩子到父节点位置</div><div class="line">输入：待旋转节点k1,</div><div class="line">输出：旋转后的树根</div><div class="line">	k2=k1的右孩子</div><div class="line">	让k1的右指针指向k2的的左孩子</div><div class="line">	让k2左指针指向k1</div><div class="line">	更新k1的高度信息为max(k1左孩子的高度，k1右孩子的高度)+1</div><div class="line">	更新k2的高度信息为max（k1的高度，k2右孩子孩子的高度）+1</div><div class="line">	返回k2</div></pre></td></tr></table></figure></p>
<p>那么我们可以轻易的写出这两个函数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">height</span><span class="params">(AvlNode&lt;T&gt;node)</span> </span>&#123;<span class="comment">//高度函数，在节点为null的时候返回-1</span></div><div class="line">	<span class="keyword">return</span> node==<span class="keyword">null</span>?-<span class="number">1</span>:node.height;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">private</span> AvlNode&lt;T&gt; <span class="title">rotateWithLeftChild</span><span class="params">(AvlNode&lt;T&gt; k1)</span></span>&#123;</div><div class="line">	AvlNode&lt;T&gt; k2=k1.left;</div><div class="line">	k1.left=k2.right;<span class="comment">//k1的左子树换成k2的右子树</span></div><div class="line">	k2.right=k1;<span class="comment">//k2的右子树变k1</span></div><div class="line">	k1.height=Math.max(height(k1.left), height(k1.right))+<span class="number">1</span>;</div><div class="line">	k2.height=Math.max(height(k2.left), k1.height)+<span class="number">1</span>;<span class="comment">//k1现在是k2的右子树根</span></div><div class="line">	<span class="keyword">return</span> k2;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> AvlNode&lt;T&gt; <span class="title">rotateWithRightChild</span><span class="params">(AvlNode&lt;T&gt; k1)</span></span>&#123;</div><div class="line">	AvlNode&lt;T&gt; k2=k1.right;</div><div class="line">	k1.right=k2.left;</div><div class="line">	k2.left=k1;</div><div class="line">	k1.height=Math.max(height(k1.left), height(k1.right))+<span class="number">1</span>;</div><div class="line">	k2.height=Math.max(k1.height, height(k2.right))+<span class="number">1</span>;<span class="comment">//k1现在是k2的左子树根</span></div><div class="line">	<span class="keyword">return</span> k2;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>单旋转</strong>操作只需要调用上面的单次旋转操作即可，而<strong>双旋转</strong>需要两次旋转操作，以左右不平衡来说，我们的解决思路如一下伪代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">描述：左右不平衡条件下的双旋转操作</div><div class="line">输入：不平衡节点k1</div><div class="line">输出：新的平衡树根</div><div class="line">	k2=k1的左孩子</div><div class="line">	k1的左孩子=旋转k2的右孩子到k2的位置后的新树根（rotateWithRightChild(k2)）</div><div class="line">	newRoot=旋转k1的左孩子到k1的位置后的新树根（rotateWithLeftChild(k1)）</div><div class="line">	返回newRoot</div></pre></td></tr></table></figure></p>
<p>相信看了这个伪代码，你也可以很容易的写出右左不平衡条件下的双旋转操作，这里就不再写出。<br>其代码实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> AvlNode&lt;T&gt; <span class="title">doubleRotateWithLeftChild</span><span class="params">(AvlNode&lt;T&gt; k1)</span></span>&#123;</div><div class="line">	AvlNode&lt;T&gt; k2=k1.left;</div><div class="line">	k1.left=rotateWithRightChild(k2);</div><div class="line">	<span class="keyword">return</span> rotateWithLeftChild(k1);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> AvlNode&lt;T&gt; <span class="title">doubleRotateWithRightChild</span><span class="params">(AvlNode&lt;T&gt; k1)</span></span>&#123;</div><div class="line">	AvlNode&lt;T&gt;k2=k1.right;</div><div class="line">	k1.right=rotateWithLeftChild(k2);</div><div class="line">	<span class="keyword">return</span> rotateWithRightChild(k1);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>实现了基本旋转操作之后，我们就可以在这个基础上编写一个调整函数来判定一个节点应该做什么样的调整，输入的节点可以是树中的任何一个节点，我们这个函数要做的有两件事情1）判定该节点是不是不平衡节点，如果是，则完成调整操作，2）更新该节点的高度信息。尽管旋转操作中更新了高度信息，我们还要照顾不需要旋转的情况，所有在算法结尾我们还是要重新计算一下根节点的高度，该其基本思路是如下伪代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">描述：平衡一个节点并返回平衡后的树根</div><div class="line">输入：树的一个节点k1</div><div class="line">输出：新的平衡树根</div><div class="line">	if k1为null</div><div class="line">		直接返回k1</div><div class="line">	if k1左子树的高度-右子树的高度&gt;1 //k1为不平衡节点，并且是左子树高的情况</div><div class="line">		k2=k1左子树根</div><div class="line">		if k2左子树的高度&gt;=右子树的高度 //左左不平衡的情况</div><div class="line">		//在插入的情况下只有大于，但是在删除的情况下有可能等于，这个情况会在删除中详细讨论。</div><div class="line">			k1=rotateWithLeftChild(k1)</div><div class="line">		else //左右不平衡的情况，双旋</div><div class="line">			k1=doubleRotateWithLeftChild(k1)</div><div class="line">	elseif k1的右子树的高度-左子树的高度&gt;1 //右子树高的情况</div><div class="line">		if k1的右子树的高度&gt;=左子树的高度</div><div class="line">			k1=rotateWithRightChild(k1)</div><div class="line">		else//右左不平衡的情况</div><div class="line">			k1=doubleRotateWithRightChild(k1)</div><div class="line">	计算根节点k1新的高度值k1.height为其左右子树高度值的最大值+1</div><div class="line">	返回新最终根节点k1</div></pre></td></tr></table></figure></p>
<p>其代码实现我们用一个叫做balance的函数实现，其实现过程遵循前面的算法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> AvlNode&lt;T&gt; <span class="title">balance</span><span class="params">(AvlNode&lt;T&gt; k1)</span></span>&#123;</div><div class="line">	<span class="keyword">if</span>(k1==<span class="keyword">null</span>)</div><div class="line">		<span class="keyword">return</span> k1;</div><div class="line">	<span class="keyword">if</span>(height(k1.left)-height(k1.right)&gt;<span class="number">1</span>) &#123;<span class="comment">//左子树更高的情况</span></div><div class="line">		AvlNode&lt;T&gt; k2=k1.left;</div><div class="line">		<span class="keyword">if</span>(height(k2.left)&gt;=height(k2.right)) &#123;<span class="comment">//左左不平衡情况</span></div><div class="line">			k1=rotateWithLeftChild(k1);</div><div class="line">		&#125;<span class="keyword">else</span> &#123;<span class="comment">//左右不平衡情况</span></div><div class="line">			k1=doubleRotateWithLeftChild(k1);</div><div class="line">		&#125;</div><div class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(height(k1.right)-height(k1.left)&gt;<span class="number">1</span>) &#123;<span class="comment">//右子树更高的情况</span></div><div class="line">		AvlNode&lt;T&gt;k2=k1.right;</div><div class="line">		<span class="keyword">if</span>(height(k2.right)&gt;=height(k2.left)) &#123;<span class="comment">//右右不平衡的情况</span></div><div class="line">			k1=rotateWithRightChild(k1);</div><div class="line">		&#125;<span class="keyword">else</span> &#123;<span class="comment">//右左不平衡的情况</span></div><div class="line">			k1=doubleRotateWithRightChild(k1);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//再算一遍新根的高度，处理非不平衡的情况</span></div><div class="line">	k1.height=Math.max(height(k1.left), height(k1.right))+<span class="number">1</span>;</div><div class="line">	<span class="keyword">return</span> k1;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>完成了一个节点的平衡，我们就可以继续推进，接下来的问题就是执行插入，并且在插入后进行回溯，对回溯到节点执行balance操作即可。其算法思想如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">描述：向一个树中插入一个节点</div><div class="line">输入：插入节点值为x, 待插入树的树根root</div><div class="line">输出：插入节点x的后的平衡二叉树根</div><div class="line">初始化:pathStack用于存储对比路径</div><div class="line">	if root等于null</div><div class="line">		返回 节点值为x的新节点</div><div class="line">	currentNode初始化为root</div><div class="line">	while currentNode不为null do</div><div class="line">		if x&lt;currentNode节点的值//插入点在左子树上</div><div class="line">			pathStack.push(currentNode)</div><div class="line">			currentNode=currentNode的左孩子</div><div class="line">		elseif x&gt;currentNode节点的值//插入点在右子树上</div><div class="line">			pathStack.push(currentNode)</div><div class="line">			currentNode=currentNode的右孩子</div><div class="line">		else//等于的情况,说明节点已经存在</div><div class="line">			直接返回root</div><div class="line">	currentNode=pathStack.pop()//返回待插入节点的父节点</div><div class="line">	if x&gt;currentNode节点的值</div><div class="line">		currentNode的右孩子=newNode(x)</div><div class="line">	else</div><div class="line">		currentNode的左孩子=newNode(x)</div><div class="line">	while pathStack不为空 do</div><div class="line">		nextNode=pathStack.pop()</div><div class="line">		if nextNode的左孩子等于currentNode</div><div class="line">			nextNode的左孩子=balance(currentNode)</div><div class="line">		else if nexNode的右孩子等于currentNode</div><div class="line">			nextNode的右孩子=balance(currentNode)</div><div class="line">		currentNode=nextNode</div><div class="line">	//当栈为空的时候还有最后一个节点没有balance，它就是currentNode</div><div class="line">	返回 balance(currentNode)</div></pre></td></tr></table></figure></p>
<p>实现代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> AvlNode&lt;T&gt; <span class="title">insert</span><span class="params">(T x, AvlNode&lt;T&gt;root)</span></span>&#123;</div><div class="line">	Stack&lt;AvlNode&lt;T&gt;&gt; pathStack=<span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">	<span class="keyword">if</span>(root==<span class="keyword">null</span>)</div><div class="line">		<span class="keyword">return</span> <span class="keyword">new</span> AvlNode&lt;T&gt;(x);</div><div class="line">	AvlNode&lt;T&gt; currentNode=root;</div><div class="line">	<span class="keyword">while</span>(currentNode!=<span class="keyword">null</span>) &#123;</div><div class="line">		<span class="keyword">if</span>(x.compareTo(currentNode.element)&lt;<span class="number">0</span>) &#123;</div><div class="line">			pathStack.push(currentNode);</div><div class="line">			currentNode=currentNode.left;</div><div class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(x.compareTo(currentNode.element)&gt;<span class="number">0</span>) &#123;</div><div class="line">			pathStack.push(currentNode);</div><div class="line">			currentNode=currentNode.right;</div><div class="line">		&#125;<span class="keyword">else</span> &#123;</div><div class="line">			<span class="keyword">return</span> root;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	currentNode=pathStack.pop();</div><div class="line">	<span class="keyword">if</span>(x.compareTo(currentNode.element)&lt;<span class="number">0</span>)</div><div class="line">		currentNode.left=<span class="keyword">new</span> AvlNode&lt;T&gt;(x);</div><div class="line">	<span class="keyword">else</span></div><div class="line">		currentNode.right=<span class="keyword">new</span> AvlNode&lt;T&gt;(x);</div><div class="line">	<span class="keyword">while</span>(!pathStack.isEmpty()) &#123;</div><div class="line">		AvlNode&lt;T&gt;nextNode=pathStack.pop();</div><div class="line">		<span class="keyword">if</span>(nextNode.right==currentNode)</div><div class="line">			nextNode.right=balance(currentNode);</div><div class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(nextNode.right==currentNode)</div><div class="line">			nextNode.left=balance(currentNode);</div><div class="line">		currentNode=nextNode;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//剩余最后一个 节点没有balance</span></div><div class="line">	<span class="keyword">return</span> balance(currentNode);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>另外一种是使用递归的方式来进行插入平衡，其核心思想如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">描述：向一个树中插入一个节点</div><div class="line">输入：插入节点值为x, 待插入树的树根root</div><div class="line">输出：插入节点x的后的平衡二叉树根</div><div class="line">	if root为null</div><div class="line">		返回新节点newNode(x)</div><div class="line">	if x&gt;root的值</div><div class="line">		root的右孩子=以root的右孩子作为树根插入x</div><div class="line">	if x&lt;root的值</div><div class="line">		root的左孩子=以root的左孩子作为树根插入x</div><div class="line">	newRoot=balance当前的树根至平衡节点</div><div class="line">	return newRoot</div></pre></td></tr></table></figure></p>
<p>代码实现很简洁<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> AvlNode&lt;T&gt; <span class="title">insertRecursive</span><span class="params">(T x, AvlNode&lt;T&gt;root)</span></span>&#123;</div><div class="line">	<span class="keyword">if</span>(root==<span class="keyword">null</span>) &#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">new</span> AvlNode&lt;T&gt;(x);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="keyword">if</span>(x.compareTo(root.element)&gt;<span class="number">0</span>)</div><div class="line">		root.right=insertRecursive(x, root.right);</div><div class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(x.compareTo(root.element)&lt;<span class="number">0</span>)</div><div class="line">		root.left=insertRecursive(x, root.left);</div><div class="line">	<span class="keyword">return</span> balance(root);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>测试代码，插入31个有序Integer数字，并且按层打印，看其功能性，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">	<span class="keyword">int</span> MAX=<span class="number">1000000</span>;</div><div class="line">	<span class="keyword">long</span> current=System.currentTimeMillis();</div><div class="line">	AvlTree&lt;Integer&gt;avlTree=<span class="keyword">new</span> AvlTree&lt;&gt;();</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=MAX;i++) &#123;</div><div class="line">		avlTree.insert(i);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">long</span> end=System.currentTimeMillis();</div><div class="line">	System.out.println(<span class="string">"建立平衡二叉树时间："</span>+(end-current)+<span class="string">"ms"</span>);</div><div class="line">	<span class="comment">//层序遍历按层打印该树</span></div><div class="line">	Queue&lt;AvlNode&lt;Integer&gt;&gt;queue=<span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">	<span class="keyword">int</span> cur=<span class="number">1</span>;<span class="comment">//当前层需要遍历的个数</span></div><div class="line">	<span class="keyword">int</span> next=<span class="number">0</span>;<span class="comment">//下一次需要遍历的个数</span></div><div class="line">	queue.offer(avlTree.getRoot());</div><div class="line">	<span class="keyword">while</span>(!queue.isEmpty()) &#123;</div><div class="line">		AvlNode&lt;Integer&gt;curNode=queue.poll();</div><div class="line">		System.out.print(curNode.element+<span class="string">"  "</span>);</div><div class="line">		cur--;</div><div class="line">		<span class="keyword">if</span>(curNode.left!=<span class="keyword">null</span>) &#123;</div><div class="line">			queue.offer(curNode.left);</div><div class="line">			next++;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span>(curNode.right!=<span class="keyword">null</span>) &#123;</div><div class="line">			queue.offer(curNode.right);</div><div class="line">			next++;</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		<span class="keyword">if</span>(cur==<span class="number">0</span>) &#123;</div><div class="line">			System.out.println();</div><div class="line">			cur=next;</div><div class="line">			next=<span class="number">0</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行结果如图6所示，2微秒建立的平衡二叉树，可以看出有序插入点情况下建立的是完全二叉树。</p>
<p><img src="http://i.imgur.com/w4ZXMcy.png" alt=""><br>图6:测试结果</p>
<p>两种方式均能正确的完成平衡二叉树的插入，那么时间性能又如何呢，我们插入100,0000个数字做对比。结果是递归为1039ms，非递归为1263ms,两者相差不大，在平衡二叉树中递归的方式更高效一点。</p>
<h2 id="Java-AVL树删除的实现"><a href="#Java-AVL树删除的实现" class="headerlink" title="Java AVL树删除的实现"></a>Java AVL树删除的实现</h2><p>在探讨AVL树的删除之前，我们先谈论二叉查找树的删除，其实二叉查找树的删除的解决的主要问题是：在删除掉指定节点后如何将被删除节点再连接到被删除节点的父节点上，使其继续保持二叉查找树的性质。在删除的过程中，我们总共可能会遇到三种情况，解决了这三种情况下的删除，也就解决了主要问题。</p>
<ul>
<li>待删除节点的左右子树为空。这种情况直接删除待删除节点，并且置待删除节点为null</li>
<li>待删除节点有左儿子或右儿子。直接用左儿子或者右儿子代替待删除节点的位置</li>
<li>待删除节点既有左儿子又有右儿子。做法是将待删除节点换成其右子树上节点最小的值，并删除最小值的节点，这种做法的考量是待删除节点的右子树的最小值一定没有左孩子，这样可以在删除该节点的时候更容易。</li>
</ul>
<p>按照上面的想法，我们给出二叉查找树删除一个节点的递归过程的伪代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">描述：在二叉查找树上删除一个节点</div><div class="line">输入：删除的节点值x，待删除节点二叉查找树的树根root</div><div class="line">输出：删除节点后二叉查找树的树根</div><div class="line">	if t=null</div><div class="line">		未找到，直接返回null</div><div class="line">	if x&gt;root的值</div><div class="line">		x在右子树上</div><div class="line">		root.right=以root.right为树根删除x后的新树根</div><div class="line">	else if x&lt;root的值</div><div class="line">		x在左子树上</div><div class="line">		root.left=以root.left为树根删除x后的新树根</div><div class="line">	//开始x=root的值</div><div class="line">	else if root.left==null并且root.right==null</div><div class="line">		直接返会null</div><div class="line">	else if root.left!=null并且root.right!=null</div><div class="line">		root的值=root.right上的最小值</div><div class="line">		root.right=以root.right为树根删除root.right上的最小值后的新树根</div><div class="line">	else</div><div class="line">		root的左子树不为空或者右子树不为空</div><div class="line">		root=root.left和root.right不为空者</div><div class="line">	返回root</div></pre></td></tr></table></figure></p>
<p>其实现Java实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> AvlNode&lt;T&gt; <span class="title">remove</span><span class="params">(T x, AvlNode&lt;T&gt;root)</span></span>&#123;</div><div class="line">		<span class="keyword">if</span>(root==<span class="keyword">null</span>)</div><div class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">		<span class="keyword">if</span>(x.compareTo(root.element)&gt;<span class="number">0</span>) &#123;</div><div class="line">			root.right=remove(x,root.right);</div><div class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(x.compareTo(root.element)&lt;<span class="number">0</span>) &#123;</div><div class="line">			root.left=remove(x,root.left);</div><div class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.left!=<span class="keyword">null</span>&amp;&amp;root.right!=<span class="keyword">null</span>) &#123;</div><div class="line">			root.element=findMin(root.right).element;</div><div class="line">			root.right=remove(root.element,root.right);</div><div class="line">		&#125;<span class="keyword">else</span> &#123;</div><div class="line">			root=(root.left==<span class="keyword">null</span>?root.right:root.left);</div><div class="line">			<span class="comment">//这种情况涵盖了左右子树都为空和只有左子树或右子树的情况</span></div><div class="line">			<span class="comment">//如果都为空，那么会root会返回null，如果 左儿子为空，则会返回右孩子的引用</span></div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> root;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>了解了二叉查找树的删除情况及其实现方式，其实我们很容易想到如何删除AVL树中的一个节点，其实前面的步骤都是相似的，我们只需要在每次删除后进行balance调整，由于整个过程是个递归的过程，所以最终在删除结束后会进行类似插入一样的回溯过程。整个Java实现只需要将最后一行return root，变成return balance(root)，其代码如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> AvlNode&lt;T&gt; <span class="title">remove</span><span class="params">(T x, AvlNode&lt;T&gt;root)</span></span>&#123;</div><div class="line">		<span class="keyword">if</span>(root==<span class="keyword">null</span>)</div><div class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">		<span class="keyword">if</span>(x.compareTo(root.element)&gt;<span class="number">0</span>) &#123;</div><div class="line">			root.right=remove(x,root.right);</div><div class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(x.compareTo(root.element)&lt;<span class="number">0</span>) &#123;</div><div class="line">			root.left=remove(x,root.left);</div><div class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.left!=<span class="keyword">null</span>&amp;&amp;root.right!=<span class="keyword">null</span>) &#123;</div><div class="line">			root.element=findMin(root.right).element;</div><div class="line">			root.right=remove(root.element,root.right);</div><div class="line">		&#125;<span class="keyword">else</span> &#123;</div><div class="line">			root=(root.left==<span class="keyword">null</span>?root.right:root.left);</div><div class="line">			<span class="comment">//这种情况涵盖了左右子树都为空和只有左子树或右子树的情况</span></div><div class="line">			<span class="comment">//如果都为空，那么会root会返回null，如果 左儿子为空，则会返回右孩子的引用</span></div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> balance(root);</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>测试我们建立1-31的二叉平衡树，然后删除8，结果如下，可以看到，8删除的位置被9顶底，10的左子树没了：</p>
<p><img src="http://i.imgur.com/bUBGV76.png" alt=""><br>图7：删除测试结果</p>
<p><strong>本文全部源码请点击这里<a href="https://github.com/buwenqi/DataStructure/tree/master/src/avltree" target="_blank" rel="external">AVLTree</a></strong></p>
<p>大功告成，放学校美图一张^_^</p>
<center><br><img src="http://i.imgur.com/1rbM75o.jpg" alt=""><br></center>

<hr>
<p>补充：<br>我们在balance的算法中在对比的过程中，其中用到了<strong>大于等于</strong>和<strong>小于等于</strong>而不是大于或者等于，如图8红色框内所示,我们是在k2左子树的高度<strong>大于等于</strong>右子树的高度进行左孩子单旋转，而不是<strong>大于</strong>，原因在于什么？插入过程中，如果遇到了左左不平衡情况，那么k2的左子树高度一定是大于右子树的高度，大于等于是包括大于的，所以在插入不平衡的情况并不影响其功能性。</p>
<p>关键在于我们在删除的时候也复用的balance函数，而删除的情况却会遇到这种左子树右右子树的情况，这种是什么情况呢，如图9所示.</p>
<center><br><img src="http://i.imgur.com/QwnFE74.png" alt=""><br>图8：等于的情况<br></center><br>假设右子树最后一层近剩一个k3,那么删除k3的结果会导致左左不平衡，并且左子孩子的左右子树均相等。这种情况单旋转即可恢复平衡。那么左右双旋转是否也可以恢复平衡，答案是肯定的，详细见图10。<br><center><br><img src="http://i.imgur.com/MTgzaxG.png" alt=""><br>图9：左左不平衡，左孩子左右子树高度相等的情况，单旋转操作可以恢复平衡<br></center><br>图10中，我们把B子树分成了以k3为根，B1和B2子树为左右子树的树，并且B1和B2中至少有一个的高度等于A子树的高度-1(我们做出这种推测的前提是B树和A树的高度相等)，左右双旋转后可以看到在B1和B2中至少有一个的高度等于A子树的高度-1，我们旋转后的树都是平衡的，所以双旋转也是可以恢复到平衡状态的，只是这样比单旋转要更多的操作，所以我们在左左不平衡情况下不平衡节点的左孩子的左子树和右子树等高的情况下，选择做单旋转。<br><center><br><img src="http://i.imgur.com/sAJ6KSt.png" alt=""><br>图10:采用左右双旋转的方式恢复平衡(左孩子左右子树高度相同)<br></center>
      
    </div>
    
    
    

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>坚持原创技术分享，您的支持将鼓励我继续创作！</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wechatpay.png" alt="Wenqi 微信支付"/>
        <p>微信支付</p>
      </div>
    

    

    

  </div>
</div>

      </div>
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/数据结构/" rel="tag"># 数据结构</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/08/04/栈和队列/" rel="next" title="栈和队列">
                <i class="fa fa-chevron-left"></i> 栈和队列
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/08/17/伸展树（splay tree）/" rel="prev" title="伸展树（splay tree）">
                伸展树（splay tree） <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
    </div>
  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/me.jpg"
                alt="Wenqi" />
            
              <p class="site-author-name" itemprop="name">Wenqi</p>
              <p class="site-description motion-element" itemprop="description">To do one thing well.</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">32</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/buwenqi" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://cn.linkedin.com/in/buwenqi" target="_blank" title="Linkin">
                      
                        <i class="fa fa-fw fa-globe"></i>Linkin</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-inline">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                友情链接
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://mijack.github.io/" title="Mi&Jack" target="_blank">Mi&Jack</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://wintercolor.tech/" title="MengNan" target="_blank">MengNan</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://mengqi92.github.io/" title="MengQi" target="_blank">MengQi</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是AVL树？"><span class="nav-number">1.</span> <span class="nav-text">什么是AVL树？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何在插入一个节点的时候保持树的平衡？"><span class="nav-number">2.</span> <span class="nav-text">如何在插入一个节点的时候保持树的平衡？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-AVL树插入的实现"><span class="nav-number">3.</span> <span class="nav-text">Java AVL树插入的实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-AVL树删除的实现"><span class="nav-number">4.</span> <span class="nav-text">Java AVL树删除的实现</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2017 &mdash; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Wenqi</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a></div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  










  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'RPU1pwQvesuCO2LV5JkRjQwQ-gzGzoHsz',
        appKey: 'gMI3tTWeJP6JoKoS55sW8Ob8',
        placeholder: '欢迎吐槽！^_^',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("RPU1pwQvesuCO2LV5JkRjQwQ-gzGzoHsz", "gMI3tTWeJP6JoKoS55sW8Ob8");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  

  

  

  

</body>
</html>
